<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何批量删除指定的GitHub Repos]]></title>
    <url>%2F2019%2F01%2F19%2F%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4github-repos%2F</url>
    <content type="text"><![CDATA[正常情况下，如果需要删除GitHub上不需要的repos，手动删除的操作有点繁琐。如果只要删除一个还能接受，手动删除多个repos就有点浪费时间了。其实我们可以通过GitHub的API接口来批量删除不需要的repos。 将要删除的repos按照username\repos-name的格式以一行一个存放到文本文件中。 在GitHub上申请具有删除repos权限的token。 在命令行中运行下面的命令： Linux 1while read r;do curl -XDELETE -H &apos;Authorization: token xxx&apos; &quot;https://api.github.com/repos/$r &quot;;done &lt; repos Windows(PowerShell) 12[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12get-content D:\repolist.txt | ForEach-Object &#123; Invoke-WebRequest -Uri https://api.github.com/repos/$_ -Method “DELETE” -Headers @&#123;"Authorization"="token xxx"&#125; &#125;]]></content>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(译)在2019使用差异化服务]]></title>
    <url>%2F2019%2F01%2F19%2F2019%E5%B7%AE%E5%BC%82%E5%8C%96%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[原文地址：Doing Differential Serving in 2019原文作者：Jeremy Wagne译文出自：FE-star/speed译者：smallbonelu校对者：[]本文链接：[] 如果你正在阅读本文，那么你可能就是那种一直在寻找务实，前瞻性思维方式来提高网站速度的人。所以，当我读了由菲尔·沃尔顿写的一个被称为差异化服务的指南后，我很感兴趣。如果你还没有听说过这种技术，其实就是你可以为你的站点编译和提供两个独立的JavaScript捆绑包： 一个捆绑包包含所有的Babel-fied转换和polyfills，适用于所有浏览器 - 只提供给实际需要它们的旧版浏览器。这可能是你已经生成的包。 第二个捆绑包具有与第一个包相同的功能，但几乎没有做转换或polyfills。此包仅供可以使用它们的现代浏览器使用。 我们使用Babel来转换脚本，以便我们可以在任何地方使用它们，但是我们这样做会有一些危险。它在大多数配置中添加的额外代码对于现代浏览器上的用户来说通常不是必要的。通过一些努力，可以更改构建过程，以减少我们在现代浏览器上发送给大量用户的代码量，同时保持对遗留客户端（例如IE11）的兼容性。差异化服务的目的不仅仅是改善传送时间 - 这肯定对传送时间有所帮助。它还可以通过减少浏览器需要处理的脚本数量来帮助减少主线程的阻塞，这是一个资源密集型处理过程。 在本指南中，你将了解如何在2019年的构建管道中设置差异化服务，从设置Babel到你需要在webpack中进行哪些调整，以及完成所有这些工作的好处。 设置你的Babel配置输出同一应用程序的多个构建版本涉及每个目标的Babel配置。毕竟，单个项目中的多个Babel配置并不罕见。通常通过将每个单独的配置对象放在env对象键下来完成。以下是为差异化服务设置的Babel配置中的内容： 12345678910111213141516171819202122232425262728293031323334353637383940// babel.config.jsmodule.exports = &#123; env: &#123; // 这是我们将用于为旧版浏览器生成捆绑包的配置 legacy: &#123; presets: [ [ "@babel/preset-env", &#123; modules: false, useBuiltIns: "entry", // 这应该合理地针对旧浏览器. targets: "&gt; 0.25%, last 2 versions, Firefox ESR" &#125; ] ], plugins: [ "@babel/plugin-transform-runtime", "@babel/plugin-syntax-dynamic-import" ] &#125;, // 这是用来为现代浏览器生成包的配置. modern: &#123; presets: [ [ "@babel/preset-env", &#123; modules: false, targets: &#123; // 这将针对支持ES模块的浏览器. esmodules: true &#125; &#125; ] ], plugins: [ "@babel/plugin-transform-runtime", "@babel/plugin-syntax-dynamic-import" ] &#125; &#125;&#125;; 你会注意到有两种配置：modern和legacy。这些都控制着Babel如何转换每个包。讽刺的是，将polyfills并添加不必要的变换到我们的代码的工具与我们可以用来发送更少代码的是同一个工具。在Phil的原始文章中，他使用Babel 6 babel-preset-env来实现这一目标。现在Babel 7发布了，我改用了@babel/preset-env。 首先要注意的是，@babel/preset-env每个配置中使用的选项都不同。对于legacy选项，我们将browserslist查询传递给适用于旧版浏览器的targets选项。我们也告诉preset包括来自@babel/polyfill与useBuiltIns选项的polyfills。除了presets，我们还包括一些必要的插件。 注意：useBuiltIns除了false之外还接受两个值。这些值是entry和usage。文档很好地解释了它们的不同之处，但值得注意的是”usage“是实验性的。与”entry”相比，它通常会产生更小的包，但我发现我需要指定”entry”才能让脚本在IE 11中运行。 对于modern配置而言，配置看起来基本相同，除了价值targets不同。我使用esmodules选项传递一个对象，而不是传递一个browserslist查询。当设置为true时，@babel/preset-env将使用较少的转换，因为预设的目标是本机支持ES模块和async/ await或其他现代功能的浏览器。useBuiltIns选项也删除了，因为项目中使用的所有功能都不需要pollyfill。也就是说，如果你使用的时现代浏览器都不能很好地支持的前沿功能，你的应用程序可能需要一些polyfill。如果你的应用程序违反此设置，请进行适当地useBuiltIns设置。 配置webpack以进行差异化服务webpack - 以及大多数其他打包工具 - 将提供一种称为多编译器模式的功能。此功能对于差异化服务至关重要。多编译器模式允许你传递多个配置对象的数组以吐出多组包： 123456// webpack.config.jsmodules.exports = [&#123; // Object config one&#125;, &#123; // Object config two&#125;]; 这很重要，因为我们可以传递两个使用相同入口点的独立配置。我们还可以根据需要调整每个配置中的规则。 不过，这说起来容易做起来难。webpack有时非常复杂，当你处理多种配置时，没有比这更复杂的了。但是，这并非不可能，所以让我们找出实现目标所需的条件吧。 从常见配置开始因为你正在对相同的入口点进行单独构建，所以你的配置将有很多共同之处。通用配置是管理这些相似性的便捷方式： 123456789// webpack.config.jsconst commonConfig = &#123; // `devMode` 是 process.env.NODE_ENV !== "production"的结果 mode: devMode ? "development" : "production", entry: path.resolve(__dirname, "src", "index.js"), plugins: [ // 在两种配置中常见的插件 ]&#125;; 从这里开始，你可以编写单独的webpack配置并使用扩展语法将常用配置合并到每个配置中： 123456789101112131415161718192021222324252627// webpack.config.jsconst legacyConfig = &#123; name: "client-legacy", output: path.resolve(__dirname, "src", "index.js"), module: &#123; rules: [ // loader... ] &#125;, // 使用扩展语法将常用配置合并到这个对象中. ...commonConfig&#125;;const modernConfig = &#123; name: "client-modern", // 注意使用.mjs扩展名 output: path.resolve(__dirname, "src", "index.mjs"), module: &#123; rules: [ // loader... ] &#125;, // 同上. ...commonConfig&#125;;module.exports = [legacyConfig, modernConfig]; 这里要说的是，如果将两种配置之间的共同点与公共对象结合起来，可以最大限度地减少必须编写的配置行。从那里，你只关注每个目标之间的关键差异。 管理两种配置既然你知道如何管理每个配置之间的共同点，那么你需要知道如何管理不同的配置。当你编译指向不同目标的公共入口点时，管理loader和插件会变得棘手。如果你处理的不仅仅是JavaScript assets，尤其如此。这是我希望会对你有所帮助的一些指导。 babel-loader可以说，你在任何webpack配置中看到的最常见的loader是babel-loader。对于我们想要实现的目标，你需要在你的新版和旧版配置对象中使用babel-loader，尽管配置稍有不同。babel-loader对于旧版浏览器目标，配置会像下面这样： 12345678910111213141516171819202122// webpack.config.jsconst legacyConfig = &#123; // ... module: &#123; rules: [ &#123; test: /\.js$/i, // 确保你的第三方库打包到独立的chunk中 // 否则这个排除模式也许会破坏你在客户端的构建 exclude: /node_modules/i, use: &#123; loader: "babel-loader", options: &#123; envName: "legacy" // 指向babel.config.js中的env.legacy &#125; &#125; &#125;, // 其他loader... ] &#125;, // ...&#125;; 在现代浏览器目标中，唯一的区别是我们将test正则表达式的值改为/\.m?js$/i来包含在npm包中的ES模块文件扩展名（.mjs）。我们还需要将options.envName的值修改为&quot;modern&quot;。options.envName指向在前面示例中babel.config.js中包含的单独配置。 1234567891011121314151617181920// webpack.config.jsconst modernConfig = &#123; // ... module: &#123; rules: [ &#123; test: /\.m?js$/i, exclude: /node_modules/i, use: &#123; loader: "babel-loader", options: &#123; envName: "modern" // 指向babel.config.js中的env.modern &#125; &#125; &#125;, // Other loaders... ] &#125;, // ...&#125;; 其他loader和插件根据你的项目，你可能有其他loader或插件来处理JavaScript以外的assets类型。如何为每个目标浏览器处理它们取决于你的项目需求，但这里有一些建议。 你可能不需要对其他loaders进行任何更改。需要记住的是，webpack不仅可以管理JavaScript，还可以管理大量其他内容。 CSS，图像，字体，基本上每一个都需要你安装一个loader。因此，为每个目标浏览器输出相同的内容（或者至少保持对assets的相同引用）非常重要。 某些loaders允许你禁用文件发射。这在差异化服务构建中很有用。例如，假设你用file-loader处理导入非JavaScript资源。在现代浏览器的配置中，你可以告诉file-loader输出文件，而在旧版浏览器的配置中，你可以指定emitFile：false以防止文件被写入磁盘两次。这可能有助于提高速度。 null-loader 对于使用多个配置来控制文件的加载和发送也可能是有用的。 小心哈希版本的assets。假设你使用图像优化加载程序（例如image-webpack-loader）来优化图像。你可能需要在两种配置中使用该loader，因为一个assets图将包含对未优化图像的引用，另一个将包含对优化图像的引用。由于每个构建的文件内容不同，因此文件哈希也会不同。结果是一组用户将获得未优化的图像assets，而其余用户将获得优化的图像assets。 插件是另一个完全不同的东西，在差异化服务设置中使用它们的最佳指导方式各不相同。例如，如果你使用copy-webpack-plugin将文件或整个目录从src复制到到dist，你只需要它在一个配置中，而不是两个。也就是说，在两种配置中使用相同的插件不会导致问题，但可能会影响构建速度。 如果你的loader和插件配置开始有点杂乱，npm脚本可以是一个很好的替代品。对于简单的项目，我经常通过npm在我的项目本地安装图像优化二进制文件（例如pngquant-bin），并在构建完成后在npm脚本中使用npx来完成这项工作。这减少了我的webpack配置中的混乱，这是一个让人乐于接受的改变。 如果你正在使用assets-webpack-plugin为两个版本生成assets清单，那么事情就会变得复杂。你需要创建单个实例以传递到每个配置的插件数组并遵循此建议。在我的一个项目中，我在Node脚本中使用assets-webpack-plugin将脚本引用注入到生成的HTML中（稍后会详细介绍）。 这些要点的要点是，你应该在构建之间保持assets引用的并行性，并且通常需要避免多次将相同的assets写入磁盘。但是，在可能已经很复杂的构建环境中也做了合理和方便的事情。 管理你的uglifier直到最近， uglify-js还是webpack的默认uglifier。在4.26.0版本中terser成为了默认设置。如果你使用的是版本4.26.0或更高版本，那么对你来说是好消息 - 你已经完成所有设置，你无需再做任何额外的构建工作！ 但是，如果你使用的是早期版本，则terser不是 默认的uglifier，而是uglify-js，你需要在你的新的配置中使用terser。这是因为uglify-js无法理解ES5之外的JavaScript语法。它无法识别像箭头函数，async/ await，等等这些东西。 对于你的旧配置，你不需要做任何事情，因为它应该已经构建好了。但是，对于你新的配置，你需要为你的项目npm install terser-webpack-plugin。然后你需要添加terser-webpack-plugin到optimization.minimizer数组： 1234567891011121314151617// webpack.config.jsconst TerserWebpackPlugin = require("terser-webpack-plugin");const modernConfig = &#123; // ... optimization: &#123; minimizer: [ new TerserWebpackPlugin(&#123; test: /\.m?js$/i, // 如果你要输出.mjs文件，就需要这个 terserOptions: &#123; ecma: 6 // 也可以是7或8 &#125; &#125;) ] &#125; // ...&#125;; 在我们新的配置中，我们输出带.mjs扩展名的文件。为了让terser能够识别和修改这些文件，我们需要相应地修改test正则表达式。我们还需要将ecma选项设置为6（尽管7或8也是有效值）。 将脚本引用注入HTML你也许使用html-webpack-plugin来为你的应用程序外壳（app shell）标签处理生成的HTML文件，这是有充分理由的。它是一个灵活的插件，可以处理大量关于在HTML模板中插入&lt;link&gt;和&lt;script&gt;标记的繁忙工作。不幸的是，它的&lt;script&gt;标签插入方式不支持差异化服务。你可以自行决定如何将这些脚本引用添加到HTML文件中。 幸运的是，只需要稍微动动脑就可以解决这个问题。对于我使用差异化服务的项目，我使用assets-webpack-plugin用来收集webpack生成的assets，如下所示： 1234567891011// webpack.config.jsconst AssetsWebpackPlugin = require("assets-webpack-plugin");const assetsWebpackPluginInstance = new AssetsWebpackPlugin(&#123; filename: "assets.json", update: true, fileTypes: [ "js", "mjs" ]&#125;); 从这里开始，我将旧的和新的配置中的这个assets-webpack-plugin实例添加到plugins数组中。我已经使用以下配置插件实例选项来适配我的项目： filename 指示应将assets JSON文件输出到的位置。 我设置update为true，它告诉插件为新的和旧的配置重用相同的assets JSON文件。 我更新fileTypes以确保在assets.json中包含新的配置生成的.mjs文件 从这里开始，它就是触摸hacky的地方。为了让&lt;script&gt;在我的HTML文件中引用想要的模式，我使用了一个在webpack完成后运行的npm脚本。此脚本读取由assets-webpack-plugin生成的assets.json文件并在正确的标记中进行操作。 希望html-webpack-plugin能够原生支持这一点，因为我个人不希望使用这种方法。你也许需要设计自己的临时解决方案。 这样值得吗？这篇文章你已经读了一半了，我确信这个问题仍然存在：这种技术是否值得？我的回答是一个响亮的肯定。我在我的网站上使用差异化服务，我认为这些好处不言自明： 所有的JS assets gzip（level 9） Brotli（level 11） Legacy 112.14 KB 38.6 KB 33.58 KB Modern 34.23 KB 12.94 KB 12.12 KB 对于我的网站来说，JavaScript大小减少了近70％。公平地说，随着打包规模的扩大，我注意到差异化服务所带来的节省明显减少了。在我的工作中，我经常遇到超过300 KB的捆绑包，我已经看到接近10％的东西，但这仍然是一个显着的减少！对我有利的大部分原因是我的特定项目需要相当大量的polyfill用于传统打包，而在很少甚至没有polyfill或现代打包的变换中我的项目就可以之间跳过这一步。 查看压缩统计数据并说它无关紧要也可能很诱人，但你必须始终牢记压缩只会降低给定assets的传输时间。压缩对解析/编译/执行时间没有影响。如果使用Brotli将100 KB JavaScript文件压缩到30 KB，是的，用户将很快收到它，但该文件仍然相当于100 KB的JavaScript。 在具有较低处理能力和内存的设备上，这是一个至关重要的区别。我经常在诺基亚2 Android手机上进行测试，差异化服务对加载性能的影响很明显。以下是我在实施差异化服务之前访问我的个人网站的Chrome设备中的性能跟踪： Chrome的DevTools中的网站性能跟踪显示在实施差异化服务之前的大量脚本活动。 下面是在差异化服务部署到位后它在同一设备上的表现： Chrome的DevTools中的网站性能跟踪显示差异化服务实施后脚本活动量大大减少。 脚本活动减少约66％是可靠的。当网站更快地获得互动时，它们对每个人来说都更加实用和愉快。 结论差异化服务是好东西。如果来自HTTPArchive的这种趋势是任何指标，那么生产中的大多数网站仍然会传送大量的polyfilled和转换后的遗留JS，这是很多用户根本不需要的。如果我们需要在旧版浏览器上支持用户，我们应该认真考虑这种双管齐下的方法来提供JavaScript。 如果不出意外，这应该会在未来观察JavaScript的打包大小，以及如何保持对JavaScript工具在减少我们发送给用户的代码方面的前瞻性态度上发挥作用。根据你的受众，你甚至可能不需要提供两个不同的捆绑包，但展示的配置可能会让你了解如何发送比当前更少的代码。 值得注意的是，JavaScript工具的状态经常发生变化。感觉非常像一个“快速移动和破坏东西”的空间。例如，webpack 5的alpha已经存在，并且需要进行大量更改。假设某些事情可能会坏掉并不是不合理的。有趣的是，我仍然在我的工作中看到webpack 3上的项目。升级某些项目可能需要比其他项目更多时间。这种技术 - 如文档所述 - 在未来仍然有用。 如果你有兴趣看到我现在使用此技术的网站，请查看此repo。希望你能从我的项目中学到尽可能多的东西。 资源 在今天的生产中部署ES2015 +代码 Kristofer Baxter 对此技术的repo示例 浏览器中的ECMAScript模块 在Web上使用JavaScript模块 @babel/preset-env 文档 terser文档]]></content>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(译)网络性能入门：2019年初学者指南]]></title>
    <url>%2F2019%2F01%2F19%2FGetting-started-with-web-performance-2019-beginner%E2%80%99s-guide%2F</url>
    <content type="text"><![CDATA[原文地址：Getting started with web performance: 2019 beginner’s guide原文作者：Jakub Gieryluk译文出自：FE-star/speed译者：smallbonelu校对者：[]本文链接：[] 有很多非常好的文章介绍了关于如何使用新功能X或技术Y亦或工具Z来提高网站性能。如果你对该主题不熟悉，那么浏览现代网络性能的迷宫可能会很困难。在本文中，我将尝试提供一个指南，以开始你的性能之旅。 了解你的用户在开始之前，最好知道你的用户是谁以及他们如何使用你的网站，以便以后做出明智的决定。从性能方面来看，重要的事情是： 移动与桌面浏览器的用户的比例， 通过浏览器引擎来划分用户：类似Chrome，Safari，Firefox，Edge，IE， 按国家划分用户。 你很可能已经使用了可以回答这些问题的分析工具。花一些时间来分析这些数据并将其写下来，包括分析日期，以便在需要时轻松访问，并在几个月内进行重新评估和比较。 请注意，全局统计信息通常与本地统计信息不同：特别是在数据成本较高的国家/地区，UC浏览器，Opera Mini等浏览器非常受欢迎，而其他地方几乎未使用过。 要了解用户的真实浏览体验，以及你的网站与竞争对手的比较情况，你可能需要查看Chrome UX报告。 确定测试URL提出一些URL，这些URL将成为性能分析和优化的候选者代表。你可能希望某些URL’s能够获得大量流量，随着时间的推移拥有相对稳定的内容，并且可以很好地覆盖你的网站的各种功能。 你的首页是自然的第一候选者。对于博客或新闻网站，过去流行的文章将是另一个候选者。 例如，Wikimedia的性能团队使用英语维基百科的“Barack Obama”和“Sweden”文章进行基准测试和性能监控。 了解这些工具在几个性能工具中运行你的页面，以熟悉它们并确定一些“速效方案”。不同的工具可能提供其他工具缺失的见解，或者可能比其他工具解释得更好 - 所以值得试一试所有的这些工具，看看哪些对你的特定用例最有用。 Lighthouse可能是最容易上手的工具，它提供了大量有关重度依赖JS的现代Web应用程序的详细信息：可以通过在Chrome浏览器开发工具的“Audit”选项卡中来运行，或者从任何浏览器本地运行web应用程序或WPT WebPageTest是网络性能的“瑞士军刀”，非常强大，并为高级用户提供了许多“隐藏功能”。你进入webperf的次数越多，你使用它的次数也就会越多。电影胶片和视频比较视图是它的一些杀手级功能。Using WebPageTest一书是一个很好的参考。 Yellow Lab Tools 还可以提供各种性能指标的有用细分。 虽然不是严格关注性能，但是也可以通过WebHint和RedBot查看一下，它们可以发现你网站的互操作性和正确性问题，提出改进建议，并帮助你摆脱无用的HTTP头。 另请参阅SiteSpeed.io以获取大量开源webperf工具。 除此之外，还有许多商业性能监控服务，其中一些还提供有限的免费工具。 在这一点上，你已经知道一些相对容易修复的问题（至少在理论上），但影响很大：比如未压缩资源，未优化图片等。 了解你网站的HTML获取你网站的HTML输出(也就是页面源码)（例如在Firefox和Chrome中使用快捷键Ctrl-U），重新格式化并进行分析。创建一个关于哪些标签组成了你的HTML的高级文档，为什么会使用这些标签（如果你不知道，请询问你的同事），以及占用了多少字节。 在长期维护的项目中，多年来积累的一些标签可能已经不再需要，那么就可以安全地移除它们。（如果它是第三方JavaScript库，那就附加奖励了！） 了解你网站的子资源接下来的事情是明白你的网站，了解一个页面的加载触发了哪些HTTP请求，何时触发以及为什么会触发。运行WebPageTest测试，将所有请求的列表（在底部）复制到电子表格，并分析每个请求的角色（特别是列表中的前10-20个），以及它们的重要程度可能会有所帮助。使用图表软件创建流程图可能对更好地理解它们之间的依赖关系关系也很有用。 如果你不确定给定请求的作用，你也许可以尝试阻止请求或人为的引入较大的延迟并查看网站的行为（这对于发现意外的单点故障依赖关系也很有用）。这有无数种方法可以做到：Chrome开发工具的“Request blocking”功能，Fiddler 的“AutoResponder”（具有延迟）功能，以及WebPageTest的“Block”或“SPOF”功能; 即使是任意浏览器中的广告拦截器都可以实现。 通过了解哪些请求对用户体验至关重要，哪些请求是次要的，你可以更好地确定优化工作的优先级。如果可能，请异步加载你的脚本或使用defer RequestMap是一个可用于 审核来自你的webapp的第三方请求的工具，并可帮助你发现通常不利于网站性能的长链请求。 隔离功能的方法复杂的Web应用程序通常必须实现许多功能并触发许多请求; 同时分析所有这些并不总是那么容易。通过能够轻易禁用的某些功能（例如通过查询字符串），你可以让你的生活更美好。 小范围地测试面向性能的浏览器功能通常是非常新的，因此尚未经过实战测试，这些功能可能在不同的浏览器中存在一些难以察觉的错误或实现的行为略有不同。当你将新浏览器功能直接应用于现实中的大型项目时，了解新浏览器功能的确切工作原理也可能会非常棘手。 一个好主意可能是回到基础部分，创建小的隔离HTML页面进行测试，将它们部署到公共服务器（我使用GitHub Pages），并在所有主流浏览器中运行WebPageTest测试。 由于统一的WebPageTest UI，所以可以轻松地比较浏览器引擎的行为 - 比查看不同的开发工具界面要容易得多。如果你发现了一些意外行为，那么你已经有一个简化版的测试用例可以用来向浏览器厂商提交错误报告。 想一想要测量什么大多数早期优化（如删除/压缩assets）都可以安全地执行，并且会立即带来明显的改进，通常不会导致回退。但是为了更进一步和基于长期发展的考虑，你需要确切地知道你的KPI是什么以及如何衡量它们。 这可能非常难以定义，它在很大程度上取决于你拥有的网站/网络应用程序类型。浏览器触发load或DOMContentLoaded事件的时间等“传统”指标并不适合现代网站，更不用说重度依赖JS的SPA了（单页面应用程序）。在任何情况下，请忘掉“one number to rule them all”。你很可能需要多个指标来了解全貌。 了解现有的性能指标除了难以定义之外，某些事情仍难以准确测量，特别是视觉事件（“我的图片和文字何时变得可见？”）。这很难回答，因为文本呈现可能取决于外部CSS和webfonts的可用性（如果它们正在等待下载，这可能导致所谓的不可见文本闪烁），而图片的load事件的触发也不能精准的知晓了（与在屏幕上实际渲染像素的时间相比）。 直到最近，浏览器根本没有提供足够的细节来衡量渲染性能，而WebPageTest的Speed Index和Visually Complete也就成为了金律。这些是非常复杂的指标，是通过获取一系列屏幕截图并分析渲染内容随时间变化的方式创建的，但你应该花一些时间来理解它们 ; 它们比简单的指标更好地传达用户体验。 话虽如此，浏览器（特别是Chrome）在2018年在这个领域取得了一些进展，它发布了像PerformanceObserver这样的浏览器内置APIs，这个APIs提供了诸如First Contentful Paint和First Meaningful Paint等事件。如果你对细节感兴趣，请查看Paul Irish的演讲。 创建自定义指标除了现成的指标外，你可能还需要一些于你网站的特定的自定义指标; 也许是将你的JavaScript代码中自定义事件的时间戳与资源的获取时间和大小相结合，这些信息可以从Resource Timing API来获取。 在创建自定义指标时，你可能需要混合使用定义明确，细粒度，可操作的指标（例如，“JavaScript method1()和method2()调用之间的时间”）以及可以传达真实用户体验的更高级别指标（例如“从HTML的responseStart到一个myImportantAppLifecycleEvent“的时间）。前者是明确致力于改进给定指标（以及捕捉意外回退）的良好基准。后者不太容易随着大型重构和代码更改而变化，这些更改会改善一个细粒度指标而代价就是会恶化另一个。 请注意，Navigation Timing和Resource Timing APIs在某些早期实现中存在错误; 注意异常值（负值或极大值）可能会扭曲统计数据。最后，你可能会使用像boomerang这样的库，而不是自己编写。 熟悉统计基础知识为了能够理解真实用户监控（RUM）数据，你需要了解平均值和中位数之间的差异，以及什么是百分位数。 某些类型的优化可能在中位数中不可见，但可能在第90,95和99百分位数上有很大差异。一般来说，你应该避免使用平均值，因为它们可能会产生误导，并且强烈建议考虑使用提供百分位数据和分布式分布图的工具。 请记住，独立事件是独立的 ; 你不能只对平均值或百分位数求和，并假设获得的数据具有代表性或意义。 注意分析正如本文开头所提到的，分析全局数据集可能会产生误导。例如，你网站上的某些功能可能仅供登录用户使用。这可能意味着登录页面和未登录用户的登录页面的性能前景可能会有很大差异。 确定影响性能的主要标准，并能够缩小分析视图范围，以便在多种变体（登录/未登录，移动/桌面等）之间进行比较 学会使用限制在功能强大的MacBook Pro上进行本地测试，使用光纤 + 千兆WiFi时，无论如何，你的页面都会感觉很快。但这并不是你的用户在一个中端的Android设备上使用移动网络的情况，他们也许在通勤的时候（因此网络不稳定）访问你的网页。 这就是在测试页面时使用网络和CPU限制很重要的原因。（平心而论，这可能是一次令人震惊的体验。） 你可以在你喜欢的浏览器（Chrome示例）中，在操作系统级别（可能使用像Fiddler这样的代理）通过devtools启用限制，或者在使用WebPageTest（“高级设置”面板）运行测试时启用限制。网络限制在基准测试中也很有用，可以随时间推移获得可比较的数据。 如果你想更进一步了解，你可以尝试2G Tuesday的变化，或在你的办公室设置一个模拟慢速3G移动连接的测试WiFi。 区分延迟，带宽和CPU随着新一代移动网络的安装和升级，互联网带宽每年都在迅速提高，即使在发展中国家也是如此。现代4G连接可能比过时的固定电话更好 - 连接类型可能是一个误导因素。 另一方面，由于物理限制，延迟不会快速改善。距离你的服务器数千公里的用户的长尾，不能做任何事情来改善他们的延迟，但通过确认问题并采取行动（最小化往返次数，识别TCP慢启动，通过dns-prefetch/ preconnect/ preload等，预先启动DNS / TCP / TLS /资源请求）可以显著缓解此问题。 最后但并非最不重要的是，虽然高端移动设备与昔日的台式机一样强大，但低端设备几乎没有改进 - 它们只是变得更便宜了，但仍然使用较慢的CPU和较小的内存（尽管在相同的网络条件下）。 特别是当涉及到大的JavaScript bundles时，带宽（下载）不再是瓶颈 - CPU速度（解析和执行）才是。 了解HTTP / 1.1和HTTP / 2之间的区别HTTP / 2（简称h2，这令HTML编写者很困惑！）是HTTP协议的一个主要修订版，它显著改变了资源通过线路传输的方式，并且与HTTP / 1.1具有完全不同的性能特征。HTTP / 1世界的一些“最佳实践”（如域分片）在HTTP / 2中不再有意义，但同样重要的是，在各种浏览器和服务器中，某些HTTP / 2功能的实现是完全不同的，并且通常是不完整的。 首先，在你最喜欢的devtools网络面板，检查你的assets是通过HTTP / 1还是HTTP / 2提供（右键单击列列表并勾选Protocol条目以使其显示）。 如果你的应用程序使用多个域来存储图片，脚本和动态数据，那么你很可能会混合使用这两者。一旦了解了这一点，请调整每个传输的最佳实践。通常，你应该尝试尽可能多地重用HTTP / 2连接 ; 浏览器会尝试通过将某些请求“合并”到同一个连接中，每个浏览器的实现会略有不同。 （请记住，大多数开发者代理 - 比如Fiddler - 默认将所有连接降级到HTTP / 1.1。确保在进行性能调查时禁用它们，以避免观察到误导行为。） 通常，从2018年末开始，WebPageTest提供了比浏览器的devtools更高级的HTTP / 2信息，因此如果你对某些assets使用HTTP / 2，则应该花时间探索WPT瀑布流和连接视图。 成为瀑布流视图的朋友WebPageTest是一个非常强大的工具，你可以从其瀑布流和连接视图中读取大量信息。这是一个完整的单独博客文章的主题，但简单来说，下面是你开始最能操作的信息： 瀑布流的形状（越“垂直”越好）， “网络静默”的缝隙， 关键资源的DNS，TCP，TLS的请求延时— preconnect或dns-prefetch是直接候选解决方案 了解瀑布流对于进行非凡的优化至关重要。你可以从这个关于瀑布流反模式的演示开始，然后通过自由探索逐渐深入探讨这个主题。 保持JavaScript不受影响向客户端发送大量JavaScript代码是现代Web最重要的问题之一。评估JavaScript非常昂贵 - 远远超过渲染大小相当的图像。当你遇到一个大型的现有项目时，要做很多的性能优化并不总是那么容易。话虽如此，这里有一些小技巧： 使用Chrome开发工具中的coverage选项卡查找未使用的JavaScript和CSS。 查看你使用的库并寻找更小的替代品。Bundlephobia非常适合用来进行npm artifacts比较。 确保不要导入大型库而是只使用它提供的一些小功能。实际上，你可能根本不需要某些库; 现代JavaScript非常强大，而且polyfilling的选择比以往更容易。 更新依赖关系也可能会减少你的包大小（或者恰恰相反 - 请小心），有时是间接的 - 通过避免项目中重复的传递子依赖关系。 了解你的构建工具像webpack这样的打包工具有很多配置选项可以帮助提高性能。阅读文档并完善配置可能需要一段时间，但这是一项很好的投资，可能带来很高的回报。特别是，code splitting是一种关键技术，可以最大限度地减少初始JavaScript有效负载并在加载时保持页面响应。 如果你正在使用babel来转换ES2015 +代码，请确保根据你的浏览器支持级别使用并正确配置babel-preset-env，以避免在最终打包中进行不必要的转换和polyfill。 归功于打包工具的tree-shaking（死代码消除）功能，将依赖项更新到较新的基于ES2015 +的版本可以使你的包更小。 考虑长期缓存HTTP / 1世界的“常识”是将给定页面上所需的所有JavaScript合并为单个文件。如果你只进行一次页面部署并且永远不会再更改它了，这是合理的。但是，如果你定期更新部署，并且某些模块的更改频率高于其他模块，则将它们拆分为单独的包可能更有用，即使它们总是一起使用也是如此。 当使用HTTP / 2并且保持合理的打包数量时，多次下载的首次微小的延迟对于回访者增加的缓存命中率（因此避免昂贵的网络请求）来说，支付的代价很小。 获得正确的长期缓存需要可以进行重复构建，对旧版本的webpack来说很难，甚至是webpack 4。刚刚发布的（alpha版）webpack 5承诺将开箱即用的长期缓存作为核心功能，这是一个非常好的消息。 使用开发人员版本的Web浏览器现在的Firefox（Beta / Dev Edition / Nightly），Chrome（Beta / Dev / Canary），Safari（技术预览版）的预发行版本非常稳定。他们在部署到最终用户之前提供新的Web平台功能和重要更改的预览，还提供了有关弃用功能的早期警告，并且在添加到主流版本数周/月之前通常会在在开发工具中提供显着的改进。 懂得权衡利弊改进一个指标有时意味着另一个指标的恶化; 在浏览器X中改进的可能在浏览器Y中产生回退。 提前考虑，定期测试所有主要的浏览器引擎，并确保保持平衡。在分析工具中创建视图或过滤器，以便能够快速隔离来自不同浏览器，不同国家/地区的统计信息等。部署重大更改时，请务必分别检查每个视图。 信任但要验证警惕提供银弹，却不提及任何缺点的博客文章。始终测试多种浏览器和设备类型。 例如，&lt;link rel=preload&gt;如果使用得当并且符合你的需求的话，它是一个很好的功能，但是如果使用不当，它实际上可能会过度优先处理某些请求导致性能下降，从而牺牲了更重要的请求。 另一个例子：&lt;script type=&quot;module&quot;&gt;/ &lt;script nomodule&gt;是一种很有前途的模式，用于将现代JavaScript传输到现代浏览器并将ES5转换为传统的JS，但它会在某些浏览器中产生重复请求。 请记住，一种方法不能解决所有问题对高带宽网络用户有利的事情 - 例如预加载（prefetching） - 对于数据套餐有限或带宽有限的用户（发展中国家，数据漫游用户）并不总是有利。网络信息API，客户端提示，通过service worker重写动态请求可能有助于缓解这些问题。 性能是一个动态的目标你的网站不是孤立的。浏览器会更新并且速度更快（但有时更慢），用户会更换他们的设备，移动和固定电话网络也会升级 - 在分析长期性能KPI时请记住这一点。 你的网站的受众特征也会随着在新的国家/地区受到欢迎而发生变化，在极端情况下，当你实现真正的大规模改进时，你的全局指标可能会更糟！ 记录你学到的东西快速学习太多东西时很容易迷失。记录你发现的新东西，为有用的URL等添加书签，以便以后回顾。在issue tracker中打开tickets以进一步研究一些想法也可能起到一些作用。 联系社区perf社区并不大，但如果你遇到困难，你可以在WebPageTest论坛上依靠那些热心人士提供的帮助。Twitter也可能是一个很好的信息来源。 持续学习并保持输出，一次一件事理解Web性能的复杂性需要时间，即使具备了所有知识，找到正确的执行方案有可能很困难。有时你只需要撸起袖子加油干，然后反复试验和试错。 目前还没有人发现性能银弹。学习新事物，提出想法，尝试，测量，权衡利弊，部署改进 — 一次一个。 享受你（网站）的性能之旅！ 附加资源 如果你想了解互联网协议和网络浏览器的工作原理，Ilya Grigorik的高性能浏览器网络是一本很棒的书。 另请参阅博客文章Google Chrome中的高性能网络。 Brotli压缩 - 它会减小多少内容？ 在生产中部署ES2015 +代码 感谢Hine Courtenay为本文的草稿版本提供了大量修正，以及Doug Sillars提供的有用技巧。]]></content>
      <tags>
        <tag>Web Performance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(译)HTTP/2的优先级]]></title>
    <url>%2F2018%2F12%2F29%2FHTTP2-Prioritization%2F</url>
    <content type="text"><![CDATA[以正确的顺序请求页面资源对于快速的用户体验至关重要。想象一下，如果一个网页上有一堆图片，还有一个外部样式表，一些自定义Web字体和一些在head中的脚本。如果浏览器首先下载了所有图片并且最后加载了样式表，在所有内容都加载完毕前，页面将完全是空白页。如果浏览器首先加载了所有阻塞资源，接着是Web字体和图片，那么它可以更早地呈现页面，并让用户开始看到内容，同时加载其余的图片。我在Chrome浏览器性能工作上的大部分时间都花在了尝试优化加载资源的顺序以获得最佳用户体验上。 使用HTTP/1.x，浏览器可以完全控制资源加载顺序。每个连接一次只能支持一个资源请求，服务器会尽快返回请求的内容。浏览器可以通过决定何时请求资源以及打开多少个并行连接来安排请求。 HTTP/2让这些事情变得更好也更复杂了。浏览器可以一次请求多个资源，指定一些优先级信息来帮助确定应该如何处理这些资源，然后等待服务器发回所有数据，而不是一次请求一个。如果浏览器和服务器都支持优先级，则应使用浏览器指定的规则并使用所有可用带宽来传递资源，而不会有资源之间的相互竞争。 每个资源都获取一个stream ID来标识连接上的资源，并且有三个参数用于定义资源优先级： 父级数据流(Parent Stream)：这个数据流是一个“依赖”资源或者应该在之后被传递的数据流。有一个所有数据流共享的虚拟root stream 0。 权重(Weight)：1到256之间的数字，用于标识在多个数据流共享连接时分配给此数据流的带宽量。带宽是相对于所有其他活动的数据流的权重分配的，而不是绝对值。 独占位(Exclusive bit)：一个标志，表示应该在不与任何其他数据流共享带宽的情况下下载。 浏览器不一定同时知道所有资源，因此服务器能够在新请求到达时重新确定请求的优先级也很关键。 那么……我们是怎么做的呢？ 浏览器引擎Chrome这包括使用Chromium的优先级逻辑和网络堆栈的所有内容。 Chrome是唯一使用独占位的浏览器，它在每个资源上使用它。它构建了一长串资源，将较低优先级的资源链接到仍在等待的最后一个相同或更高优先级的资源。如果没有更高优先级的资源挂起，则启动新链。权重以静态映射的方式分配，Chrome的五个内部优先级分别对应相应的权重（即HIGHEST为256）。 假设给定几个请求队列，所有请求都设置了独占位，服务器将选择权重最高的一个，完成传递后，就将其从列表中弹出并重新选择。 假设Chrome正确构建了排序，这可能非常有效。独占下载资源是样式表和脚本等阻塞资源的最佳选择。当涉及到图片和视频时，你可能需要一些交错执行的任务（特别是对于渐进式图片）。否则，在转到下一个请求前，你将要等待每个图片或视频完全下载下来。 FirefoxFirefox实现了HTTP/2的树结构，并构建了一个虚拟的数据流树，用来对不同请求类型进行分组。Firefox对分组进行了加权，以便为更重要的组提供更多的带宽，并且当所有节点都已完成时，空闲周期(idle cycles)可用于响应。 在根级别中，有一个“leader”组，，它的带宽是“Other group”的两倍。在“leader”组中，有一个叫“follower”的子组，它只有在“leader”组的直系后代完成下载后才会开始下载。例如，在权重为200的“leader”组下面，一旦所有CSS完成下载后，图片和字体才会开始下载。一个组内的所有子资源具有相同的权重并均匀分配带宽（同时下载所有图片或所有脚本）。 从整体结构上来看Firefox非常出色，可以为推测请求定义空闲周期，但对同时下载所有资源优先级的划分并不是很好。像样式表和脚本等这样的阻塞资源的优先下载要比按顺序下载它们才能让解析器处理文档要好。 Safari这包括iOS上的所有浏览器（包括Chrome）。 Safari采用了一种非常简单的方法，看起来是SPDY优先级的遗留部分。五个内部webkit优先级静态映射到权重，并且没有定义依赖关系。所有请求基于每个资源的优先级来划分带宽权重进行同时下载（例如，脚本获得图片带宽的三倍）。 这样导致高并发性并不是很好，而且落后于Firefox的实现，在Firefox中至少follower组的资源会等到leader组资源全部完成任务之后（尽管它可能不足以证明Firefox中树的复杂性）。 Microsoft Edge / Internet Explorer简而言之，Microsoft Edge（和Internet Explorer）根本不支持优先级。所有请求均匀分配带宽（几乎是最糟糕的情况）。 Servers/Hosting/CDNs现在大多数服务器都支持HTTP/2了，通常也”支持”优先级的。支持加了引号，是因为即使一个服务器内部支持资源优先级，实际上让它能够与浏览器工作也需要调整网络堆栈并尽可能减少输出缓冲而不影响吞吐量。 缓冲可能是一个问题，因为服务器可以发送一堆低优先级的响应，这些响应在高优先级响应到来之前已经在缓冲区中排队。发送高优先级响应时，无法抢占已缓冲的低优先级响应。缓冲可以来自服务器本身，TLS层，TCP发送的缓冲，甚至来自网络上的bufferbloat，跟踪并消除所有多余的缓冲可能会很复杂。我在今年早些时候的一篇博文中谈到了一些原因和解决方案，但这并不是一个详尽的清单。 为了测试服务器优先级的有效性，我构建了一个测试页面，你可以在你的服务堆栈上部署该测试页面以查看优先级是否正常工作。它专门针对Chrome的优先级逻辑，因此最好使用慢速连接上的Chrome进行测试。它先将3MB低优先级图片排队，然后在下载并执行高优先级脚本后，脚本会发送4个高优先级请求（一张图片，一个页面背景，一个自定义的webfont和一个阻塞脚本）。当优先级正常工作时，后置的高优先级请求的资源会跳过低优先级请求并快速得到响应： 当优先级工作不正常时，部分或全部后置的高优先级请求的资源会被延迟，直到优先级较低的请求完成为止： 后置请求的阻塞脚本的延迟超出了“DOM Content Loaded”的度量值，字体和2个图片的延迟对视觉体验产生了相当大的影响： 我们从哪里开始？为了跟踪CDN和托管服务提供商支持HTTP/2优先级的程度，Andy Davies创建了一个GitHub仓库，用于跟踪当前的支持状况，任何人都可以提交测试结果来群策群力。在撰写本文时，情况非常糟糕，只有两个CDN确实正确地确定了优先级，并且存在一些非常令人震惊的失败（例如每个云提供商甚至Google的GFE）。希望通过提高对这种情况的认知，我们将能够为优先级提供更广泛的支持。 对托管和服务器来说，好消息是你总是可以在它们之前配置一个支持优先级的CDN来解决问题（尽管直接支持它会很好）。 在浏览器方面，除了敦促浏览器厂商以获得更好的支持之外，没有太多可以做的事情。其中的一些厂商可能会遇到架构问题，如他们的浏览器引擎在操作系统的网络堆栈层之上，导致无法传递优先级信息。可能是我的偏见，但我认为Chrome是最接近“正确”的做法，但仍有相当大的改进空间。 HTTP/3也即将到来，但目前的优先级方案不会改变。这个改变是网络堆栈的终结。在服务器端，这意味着操作系统的缓冲和拥塞控制不再起作用，服务器软件100％负责最小化缓冲（包括拥塞控制算法以最小化缓冲区）。 那么就说到这里，希望为了HTTP/2和一个安全，高性能的网络，我们可以在2019年修复资源优先级。 本文版权归原作者所有，仅用于学习与交流； 如需转载译文，烦请按下方注明出处信息，谢谢！ 原文地址：HTTP/2 Prioritization原文作者：[Patrick Meenan]译者：smallbonelu]]></content>
      <tags>
        <tag>HTTP/2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中对象的拷贝]]></title>
    <url>%2F2018%2F12%2F13%2FCopying-Objects-in-JavaScript%2F</url>
    <content type="text"><![CDATA[浅拷贝利用for循环遍历原始对象将原始对象中的每个属性拷贝到目标对象上，但是可能存在性能问题 12345678910111213141516171819202122function shallowCopy(sourceObj) &#123; let objCopy = &#123;&#125;; let key; for (key in sourceObj) &#123; if (sourceObj.hasOwnProperty(key)) &#123; objCopy[key] = sourceObj[key]; &#125; &#125; return objCopy;&#125;const sourceObj = &#123; a: 3, b: 5, c: &#123; x: 7, y: 9 &#125;&#125;console.log(shallowCopy(sourceObj)); 使用Object.assign()方法1234567let obj = &#123; a: 1, b: 2&#125;let objCopy = Object.assign(&#123;&#125;, obj);console.log(objCopy); 使用ES6的扩展运算符...123456let obj = &#123; one: 1, two: 2&#125;let newObj = &#123;...obj&#125;; 浅拷贝存在的问题 拷贝对象的原型链不会继承原始对象的原型链 原始对象的属性描述符(数据属性，访问器属性)不会被拷贝 只拷贝了可枚举的属性 原始对象中内嵌的对象与拷贝后对象中的内嵌对象共享内存地址 深拷贝使用JSON.parse(JSON.stringify(object))它能正确处理的对象只有 Number, String, Boolean, Array 扁平对象，即那些能够被JSON直接表示的数据结构，比如Date对象就不适用此方法。 123456789101112let obj = &#123; a: 1, b: &#123; c: 2 &#125;&#125;let newObj = JSON.parse(JSON.stringify(obj));obj.b.c = 20;console.log(obj); // &#123;a: 1, b: &#123;c: 20&#125;&#125;console.log(newObj); // &#123;a: 1, b: &#123;c: 2&#125;&#125; 缺点： 无法拷贝用户定义的对象方法(函数)，但是Object.assign()方法可以 JSON.parse(JSON.stringify(object))方法无法拷贝环对象(环对象指的是对象本身的属性之间相互引用)，但是Object.assign()方法却可以浅拷贝循环引用的对象 使用第三方库如Underscore的_.clone()，jQuery的$.clone()浅拷贝 / $.extend(true, {}, ...)可以实现深复制，lodash的_.clone() / _.cloneDeep()，其中lodash的兼容性更好一些 利用HTML5的history API利用history.pushState()和history.replaceState()两个方法都会为它们的第一个参数创建一个结构化的克隆，不过要注意的是因为这两个方法是同步的并且对浏览器历史记录的操作性能并不是很高，所以重复调用这两个方法可能会导致浏览器没有响应，影响用户体验 1234567const structuredClone = obj =&gt; &#123; const oldState = history.state; history.replaceState(obj, null); const cloneObj = history.state; history.replaceState(oldState, null); return cloneObj;&#125; 利用Notification API当利用Notification构造函数创建通知时，构造函数也会为传入的数据创建一个结构化的克隆 12345const structuredClone = obj =&gt; &#123; const n = new Notification("", &#123;data: obj, slient: true&#125;); n.onshow = n.close.bind(n); return n.data;&#125; 使用Node.JSNode.js自8.0.0版本之后提供了一个兼容结构化克隆的序列化API，但是这个API还在开发阶段，所以兼容性并不是很好 1234const v8 = require('v8');const buf = v8.serialize(&#123;a: 'foo', b: new Date()&#125;);const cloned = v8.deserialize(buf);cloned.b.getMonth(); 原生方法stackoverflow上原生Javascript实现的一个简单的对象克隆函数： 123456789101112131415161718192021222324252627282930313233function clone(obj) &#123; var copy; // Handle the 3 simple types, and null or undefined if (null == obj || "object" != typeof obj) return obj; // Handle Date if (obj instanceof Date) &#123; copy = new Date(); copy.setTime(obj.getTime()); return copy; &#125; // Handle Array if (obj instanceof Array) &#123; copy = []; for (var i = 0, len = obj.length; i &lt; len; i++) &#123; copy[i] = clone(obj[i]); &#125; return copy; &#125; // Handle Object if (obj instanceof Object) &#123; copy = &#123;&#125;; for (var attr in obj) &#123; if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]); &#125; return copy; &#125; throw new Error("Unable to copy obj! Its type isn't supported.");&#125; 总结深拷贝和浅拷贝区别：浅拷贝只复制一层对象的属性，而深拷贝则递归复制了所有层级深拷贝必须用到递归。从兼容性方面考虑，使用lodash的cloneDeep()是最佳的选择。 参考链接：Copying Objects in JavaScriptjavascript中浅拷贝和深拷贝的区别深入剖析 JavaScript 的深复制COPYING OBJECTS IN JAVASCRIPT]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BeautifulSoup4 find_all搜索包含指定文本内容的标签返回空list的问题]]></title>
    <url>%2F2018%2F08%2F30%2FBeautifulSoup4%E6%90%9C%E7%B4%A2%E5%8C%85%E5%90%AB%E6%8C%87%E5%AE%9A%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%E7%9A%84%E6%A0%87%E7%AD%BE%E8%BF%94%E5%9B%9E%E7%A9%BAlist%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近帮助公司其他团队用python写了一个爬虫，遇到了不少问题，其中就有一个问题是使用BeautifulSoup4的find_all搜索包含指定文本内容时返回的是空的list，查看了官方文档也上google搜索了一些类似的问题，发现是因为在使用bs4的find_all结合正则表达式查找指定文本的时候，搜索的是bs4返回元素中string属性中的信息，而不是text属性。并且如果某个元素中如果还包含除了文本之外的子元素，string属性返回会是None，而不是像text属性中那样的文本信息。 如果HTML中的内容结构像下面这样:1234&lt;td&gt;some text&lt;/td&gt; &lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;more text&lt;/p&gt;&lt;/td&gt;&lt;td&gt;even &lt;p&gt;more text&lt;/p&gt;&lt;/td&gt; td 上的.string属性将会返回下面的内容：1、some text2、None3、more text4、None .text 属性将会返回下面的内容：1、some text2、3、more text4、even more text 如果想要了解.find和.string之间的差异可以查看Python BeautifulSoup 中.text与.string的区别 解决办法是使用lambda函数12&gt;&gt;&gt; soup.find_all(lambda e: e.name == &apos;td&apos; and &apos;Black&apos; in e.text)[&lt;td id=&quot;rp10&quot; valign=&quot;top&quot;&gt;Black or African American alone, percent, 2013 (a) &lt;!-- RHI225213 --&gt; &lt;/td&gt;, &lt;td id=&quot;re6&quot; valign=&quot;top&quot;&gt;Black-owned firms, percent, 2007 &lt;!-- SBO315207 --&gt; &lt;/td&gt;]]]></content>
      <tags>
        <tag>BeautifulSoup4</tag>
        <tag>python爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何解决公网无法访问阿里云ECS搭建的MongoDB服务]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%85%AC%E7%BD%91%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E9%98%BF%E9%87%8C%E4%BA%91ECS%E6%90%AD%E5%BB%BA%E7%9A%84MongoDB%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[最近为了学习后端购买了一台阿里云ECS云服务器（专用网络）环境如下：OS：Ubuntu16.04，MongoDB：v4.0.1 尝试着安装了MongoDB并进行了相应的配置，搜索了一些资料发现关键在于三点： MongoDB的bindIp配置： MongoDB默认的配置文件中，bindIp选项默认是localhost，也就是说默认只有安装了MongoDB的主机自己能够访问。所以如果需要外网的主机能够访问MongoDB服务，首先需要更改bindIp选项，将其设置为指定的IP地址(x.x.x.x, …)者绑定所有的IP地址(0.0.0.0 )。MongoDB 3.6之后的版本新增了bindIpAll选项，true代表绑定所有IP地址。 配置文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142# mongod.conf# for documentation of all options, see:# http://docs.mongodb.org/manual/reference/configuration-options/# Where and how to store data.storage: dbPath: /var/lib/mongodb journal: enabled: true# engine:# mmapv1:# wiredTiger:# where to write logging data.systemLog: destination: file logAppend: true path: /var/log/mongodb/mongod.log# network interfacesnet: port: 27017 bindIpAll: true # how the process runsprocessManagement: timeZoneInfo: /usr/share/zoneinfo#security:#operationProfiling:#replication:#sharding:## Enterprise-Only Options:#auditLog:#snmp: Linux防火墙iptables的配置： 在bash中输入sudo iptables -A INPUT -p tcp --destination-port 27017 -m state --state NEW,ESTABLISHED -j ACCEPTsudo iptables -A OUTPUT -p tcp --source-port 27017 -m state --state ESTABLISHED -j ACCEPT 开放MongoDB的端口。 接着输入iptables-save和 iptables-restore保存iptables的配置信息以免主机重启后需要重新配置。 ECS主机的安全组规则配置： 经过以上的配置后，就能够远程连接阿里云ECS上搭建的MongoDB服务了。]]></content>
      <tags>
        <tag>MongoDB</tag>
        <tag>Ubuntu</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(译)7个ES6编程小技巧]]></title>
    <url>%2F2018%2F05%2F20%2F7-Hacks-for-ES6-Developers%2F</url>
    <content type="text"><![CDATA[1. 交换变量使用数组解构来交换变量的值1234let a = &apos;world&apos;, b = &apos;hello&apos;;[a, b] = [b, a];console.log(a); // helloconsole.log(b); // world 2. Async/Await和解构将数组解构和async/await以及promise结合可以使复杂的数据流变得简单1234const [user, account] = await Promise.all([ fetch(&apos;/user&apos;), fetch(&apos;/account&apos;)]); 3. Debuggingconsole.log更酷的使用方法：12345678const a = 5, b = 6, c = 7;console.log(&#123;a, b, c&#125;);// 输出//&#123;// a: 5,// b: 6,// c: 7//&#125; 4. 一行解决对于某些数组操作，可以使用更为简洁的语法1234567//找出最大值const max = (arr) =&gt; Math.max(...arr);max([123, 321, 23]); //输出 321//数组求和const sum = (arr) =&gt; arr.reduce((a, b) =&gt; (a + b), 0);sum([1, 2, 3, 4]); //输出 10 5. 数组合并扩展操作符可以用来代替concat：123456789101112const one = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];const two = [&apos;d&apos;, &apos;e&apos;, &apos;f&apos;];const three = [&apos;g&apos;, &apos;h&apos;, &apos;i&apos;];//常规方法1const result = one.concat(two, three);//常规方法2const result = [].concat(one, two, three);//新方法const result = [...one, ...two, ...three]; 6. 克隆12const obj = &#123; ...oldObj &#125;;const arr = [ ...oldArr ]; 注：以上方法创建的是一个浅克隆 7. 命名参数通过使用解构操作符让函数更易读：123456789101112const getStuffNotBad = (id, force, verbose) =&gt; &#123; ...&#125;const getStuffAwesome = (&#123; id, name, force, verbose &#125; =&gt; &#123; ...&#125;)//这种方法让人一时不知道这个几个参数表示的是什么getStuffNotBad(150, true, true);//参数意思一目了然getStuffAwesome(&#123; id: 150, force: true, verbose: true &#125;); 注： 本文版权归原作者所有，仅用于学习与交流； 如需转载译文，烦请按下方注明出处信息，谢谢！原文： 7 Hacks for ES6 Developers作者： Tal Bereznitskey译者：smallbone译文地址：https://medium.com/dailyjs/7-hacks-for-es6-developers-4e24ff425d0b 阅读原文]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何解决WebSocket的兼容性]]></title>
    <url>%2F2018%2F05%2F06%2F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3WebSocket%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[我们知道WebSocket是一种在服务器与客户端双向通讯的技术，使用原生的WebSocket可以最小化 服务器资源的使用并且为两者提供了一种统一的通信方式。随着HTML5的普及，现代浏览器（IE10+）基本上都已经原生支持WebSocket了，下面是支持WebSocket协议的浏览器： Internet Explorer 10 Firefox 6 Chrome 14 Safari 6.0 Opera 12.1 iOS Safari 6.0 Chrome for Android 27.0但是对于旧的浏览器该如何实现WebSocket的功能呢？下面就介绍一下几种常见的解决方案：1. SockJSSockJS是一个JavaScript库，它为浏览器提供了一个类似WebSocket的对象。首先，它会优先使用原生的WebSocket；如果不支持，则使用streaming；如果streaming也不支持，则使用轮询（polling）。下面是支持的浏览器概览： 既然模拟WebSocket双向通信，那么使用SockJS时，也要配合使用相应的服务器端的库，下面可以使用的服务器端库： SockJS-node SockJS-erlang SockJS-tornado SockJS-twisted SockJS-ruby SockJS-netty SockJS-gevent (SockJS-gevent fork) SockJS-go客户端的使用首先加载SockJS库1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js&quot;&gt;&lt;/script&gt; 库加载完后， 就可与SockJS服务器建立连接了1234567891011121314var sock = new SockJS(&apos;https://mydomain.com/my_prefix&apos;); sock.onopen = function() &#123; console.log(&apos;open&apos;); sock.send(&apos;test&apos;); &#125;; sock.onmessage = function(e) &#123; console.log(&apos;message&apos;, e.data); sock.close(); &#125;; sock.onclose = function() &#123; console.log(&apos;close&apos;); &#125;; 服务器端的使用(NodeJS)首先，安装sockjs-node:1npm install sockjs 接着就可以通过监听事件来与客户端进行类似WebSocket的通信了1234567891011121314var http = require(&apos;http&apos;);var sockjs = require(&apos;sockjs&apos;);var echo = sockjs.createServer(&#123; sockjs_url: &apos;http://cdn.jsdelivr.net/sockjs/1.0.1/sockjs.min.js&apos; &#125;);echo.on(&apos;connection&apos;, function(conn) &#123; conn.on(&apos;data&apos;, function(message) &#123; conn.write(message); &#125;); conn.on(&apos;close&apos;, function() &#123;&#125;);&#125;);var server = http.createServer();echo.installHandlers(server, &#123;prefix:&apos;/echo&apos;&#125;);server.listen(9999, &apos;0.0.0.0&apos;); 2. Socket.IOSocket.IO能够启用基于事件的双向通信，使用它同样也需要搭建相应的服务端；首先它也会首选WebSocket，如果不支持则会使用下面的替代方案： Adobe Flash Socket（缺点：需要在服务器上打开一个额外的端口，默认为10843） Ajax long polling Ajax multipart streaming Forever iframe JSONP polling浏览器兼容性 客户端1234567891011//加载Socket.IO库&lt;script src=&quot;http://localhost:8181/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var socket = io.connect(&apos;http://localhost:8181&apos;); console.log(&apos;a user connected&apos;); socket.emit(&apos;my other event&apos;, &#123; my: &apos;data&apos; &#125;); socket.on(&apos;disconnect&apos;, function()&#123; console.log(&apos;user disconnected&apos;); &#125;); &#125;);&lt;/script&gt; 服务端安装socket.io1npm install socket.io --save 配置服务器12345678var server = require(&apos;http&apos;).createServer();var io = require(&apos;socket.io&apos;)(server);io.on(&apos;connection&apos;, function(socket)&#123; socket.emit(&apos;news&apos;, &#123; hello: &apos;world&apos; &#125;); socket.on(&apos;event&apos;, function(data)&#123;&#125;); socket.on(&apos;disconnect&apos;, function()&#123;&#125;);&#125;);server.listen(3000);]]></content>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用File APIs来读取文件]]></title>
    <url>%2F2018%2F04%2F26%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8File-APIs%E6%9D%A5%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[兼容性检查12345if (window.File &amp;&amp; window.FileReader &amp;&amp; window.FileList &amp;&amp; window.Blob) &#123; //支持File APIs&#125; else &#123; //不支持File APIs&#125; FileReader()FileReader对象让web应用程序可以异步地读取存储在用户电脑上的文件(或者原始数据缓冲区)的内容。在JavaScript中，FileReaderd对象通过传入两种相应的对象(File和Blob)来进行数据的读取，而且这个方法在Web Workers中也能使用。 FileReader 包括四个异步读取文件的选项： FileReader.readAsBinaryString(Blob|File) - 返回值的result 属性将包含二进制字符串形式的file/blob 数据。每个字节均由一个 [0..255] 范围内的整数表示。 FileReader.readAsText(Blob|File, opt_encoding) - 返回值的result 属性将包含文本字符串形式的 file/blob 数据。该字符串在默认情况下采用“UTF-8”编码。使用可选编码参数可指定其他格式。 FileReader.readAsDataURL(Blob|File) - 返回值的result 属性将包含编码为数据网址的 file/blob 数据。 FileReader.readAsArrayBuffer(Blob|File) - 返回值的result 属性将包含 ArrayBuffer 对象形式的 file/blob 数据。 FileReader 对象调用其中某一种读取方法后，可使用 onloadstart、onprogress、onload、onabort、onerror 和 onloadend 跟踪其进度。 读取文件并显示进度下面的示例从用户选择的内容中过滤掉了图片，对文件调用 reader.readAsDataURL()，并通过将“src”属性设为数据网址来呈现缩略图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;style&gt; .thumb &#123; height: 75px; border: 1px solid #000; margin: 10px 5px 0 0; &#125; #list &#123; border: 1px solid lightgrey; padding: 15px; text-align: center; &#125; #progress_bar &#123; margin: 10px 0; padding: 3px; border: 1px solid #000; font-size: 14px; clear: both; opacity: 0; -moz-transition: opacity 1s linear; -o-transition: opacity 1s linear; -webkit-transition: opacity 1s linear; &#125; #progress_bar.loading &#123; opacity: 1.0; &#125; #progress_bar .percent &#123; background-color: #99ccff; height: auto; width: 0; &#125;&lt;/style&gt;&lt;body&gt; &lt;input type=&quot;file&quot; name=&quot;files[]&quot; id=&quot;files&quot; multiple /&gt; &lt;div id=&quot;list&quot;&gt;&lt;/div&gt; &lt;button onclick=&quot;abortRead();&quot;&gt;Cancel read&lt;/button&gt; &lt;script&gt; let reader; let progress; let progress_bar; function abortRead() &#123; reader.abort(); &#125; function errorHandler(evt) &#123; let error = evt.target.error; switch (error.code) &#123; case error.NOT_FOUND_ERR: alert(&apos;没有找到文件&apos;); break; case error.NOT_READABLE_ERR: alert(&apos;无法读取文件&apos;); break; case error.ABORT_ERR: break; default: alert(&apos;文件读取错误&apos;); &#125; &#125; function updateProgress(evt) &#123; if (evt.lengthComputable) &#123; let percentLoaded = Math.round((evt.loaded / evt.total) * 100); if (percentLoaded &lt; 100) &#123; progress.style.width = percentLoaded + &apos;%&apos;; progress.textContent = percentLoaded + &apos;%&apos;; &#125; &#125; &#125; function handleFileSelect(evt) &#123; let files = evt.target.files; //创建进度条 progress_bar = document.createElement(&apos;div&apos;); progress_bar.id = &apos;progress_bar&apos;; progress = document.createElement(&apos;div&apos;); progress.className = &apos;percent&apos;; progress.style.width = &apos;0%&apos;; progress.textContent = &apos;0%&apos;; progress_bar.appendChild(progress); document.getElementById(&apos;list&apos;).appendChild(progress_bar); for (let i = 0; i &lt; files.length; i++) &#123; reader = new FileReader(); if (!files[i].type.match(&apos;image.*&apos;)) &#123; alert(&apos;选择的文件不是图片&apos;); abortRead(); return; &#125; reader.onerror = errorHandler; reader.onprogress = updateProgress; reader.onabort = (e) =&gt; &#123; alert(&apos;文件读取已取消&apos;); &#125;; reader.onloadstart = (e) =&gt; &#123; progress_bar.className = &apos;loading&apos;; &#125;; reader.onload = (e) =&gt; &#123; let span = document.createElement(&apos;span&apos;); span.innerHTML = [&apos;&lt;img class=&quot;thumb&quot; src=&quot;&apos;, e.target.result, &apos;&quot; title=&quot;&apos;, files[i].name, &apos;&quot;/&gt;&apos;].join(&apos;&apos;); document.getElementById(&apos;list&apos;).insertBefore(span, progress_bar); progress.style.width = &apos;100%&apos;; progress.textContent = &apos;100%&apos;; &#125;; reader.readAsDataURL(files[i]); &#125; &#125; document.getElementById(&apos;files&apos;).addEventListener(&apos;change&apos;, handleFileSelect, false); &lt;/script&gt;&lt;/body&gt; See the Pen FileReader Demo by Lu (@smallbone) on CodePen. FileList API字面上可以理解为多个File对象组合成的数组，但是只有length属性和item(index)方法，访问其中的File对象既可以使用files.item(index)，也可以使用files[index]的方法。 File APIFile对象是一种特定类型的Blob。FileReader, URL.createObjectURL(), createImageBitmap(), 以及XMLHttpRequest.send() 都接受Blobs和Files。 File对象包含的信息12345678&#123; lastModified: 1428005315000, lastModifiedDate: Thu Apr 02 2015 15:08:35 GMT-0500 (CDT), name: &quot;profile.pdf&quot;, size: 135568, type: &quot;application/pdf&quot;, webkitRelativePath: &quot;&quot;&#125; 需要注意的是，type是根据文件扩展名来判断的，所以并不是很可靠。根据上面File对象的信息其实就可以实现一些常用的功能了，比如限制文件上传的大小，初步的限制文件上传的类型(当然也可以通过input元素的accept属性来实现，但是最终的类型验证还是需要在服务器端实现)。 File对象一般通过以下途径返回的FileList对象获取： &lt;input type=&quot;file&quot;&gt;的元素 拖拽操作的DataTransfer对象 通过在一个HTMLCanvasElement上调用mozGetAsFile() API 通过input来选择文件1234567/* 假设input元素为&lt;input type=&quot;file&quot; id=&quot;upload&quot; multiple&gt; *///multiple表示一次支持多个文件上传let uploadInput = document.getElementById(&apos;upload&apos;);uploadInput.addEventListener(&apos;change&apos;, ()=&gt;&#123; let fileList = uploadInput.files; console.log(fileList);&#125;); 由于FileList对象并没有forEach()方法，所以一般需要通过for循环来遍历其中的每个File对象：123for (var i = 0; fileCount = fileList.length; i &lt; fileCount; i++) &#123; console.log(fileList[i]);&#125; 但是我们也可以通过其他方式来使用forEach()方法：123456789//1.call方法[].forEach.call(fileList, (file, i, fileList)=&gt;&#123; ...&#125;);//2.ES6方法Array.from(uploadInput).forEach((i)=&gt;&#123; ...&#125;); 通过拖拽(drag&amp;drop)选择文件拖拽事件： drag(开始拖动，持续事件) dragend(释放鼠标或者按下ESC，结束拖动) dragenter(进入有效的拖拽区域时) dragexit(当一个元素不再是拖动操作的直接选择目标时) dragleave(离开有效的拖拽区域时) dragover(悬停在有效的拖拽区域内时，持续事件) dragstart(开始拖动) drop(目标放置到有效的拖拽区域时) 其中需要注意两点： 如果dragover事件不阻止默认事件，drop事件就不会被触发。 dragexit和dragleave在不同浏览器中的触发存在差异，dragexit在Chrome浏览器中就永远不会被触发。 12345678910111213141516171819202122232425262728//拖拽和显示区域&lt;div id=&quot;drop_zone&quot;&gt;Drop files here&lt;/div&gt;&lt;output id=&quot;list&quot;&gt;&lt;/output&gt;&lt;script&gt; function handleFileSelect(evt) &#123; evt.stopPropagation(); evt.preventDefault(); //注意这里不再是target.files let files = evt.dataTransfer.files; let output = []; [].forEach.call(files, (file)=&gt;&#123; output.push(&apos;&lt;li&gt;&lt;strong&gt;&apos;, file.name, &apos;&lt;/strong&gt; (&apos;, file.type || &apos;n/a&apos;, &apos;) - &apos;, (file.size/1024).toFixed(3), &apos; Kb, last modified date: &apos;, file.lastModifiedDate.toLocaleDateString(), &apos;&lt;/li&gt;&apos;); &#125;); document.getElementById(&apos;list&apos;).innerHTML = &apos;&lt;ul&gt;&apos; + output.join(&apos;&apos;) + &apos;&lt;/ul&gt;&apos;; &#125; function handleDragOver(evt) &#123; evt.stopPropagation(); evt.preventDefault(); evt.dataTransfer.dropEffect = &apos;copy&apos;; &#125; let dropZone = document.getElementById(&apos;drop_zone&apos;); dropZone.addEventListener(&apos;dragover&apos;, handleDragOver, false); dropZone.addEventListener(&apos;drop&apos;, handleFileSelect, false);&lt;/script&gt;]]></content>
      <tags>
        <tag>File APIs</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSocket简介]]></title>
    <url>%2F2018%2F04%2F21%2FWebSocket%2F</url>
    <content type="text"><![CDATA[WebSocket 是一种基于TCP的提供全双工/双向通信的通信协议，因为它原生支持跨域，且安全性较高，而且上手容易，是很好的跨域解决方案，甚至可以很容易的搭建一个聊天室。 使用方法客户端12//WebSocket接收两个参数，一个是URL(必须的)，一个是所使用的子协议（可选），可以是字符串也可以是数组，没有指定则为空字符。http使用ws，https使用wssvar ws = new WebSocket(&apos;ws://hostname:port&apos;) 服务器(NodeJS)123//create WebSocket Servervar WebSocketServer = require(&apos;ws&apos;).Server;var wss = new WebSocketServer(&#123;port: 8181&#125;); WebSocket事件 open 123ws.onopen = function(e) &#123; ...&#125; message 123ws.onmessage = function(e) &#123; ...&#125; error 123ws.onerror = function(e) &#123; ...&#125; close 123ws.onclose = function(e) &#123; ...&#125; WebSocket方法 send()可以传输两种类型的之：string和binary；因为WebSocket是事件驱动的协议，所以必须确保连接已经打开并且已经准备好接收信息了。 12345678910111213var ws = new WebSocket(&apos;ws://localhost:8181&apos;);ws.onopen = function(e) &#123; ws.send(JSON.stringigy(stock_request));&#125;//orfunction processEvent(e) &#123; if(ws.readState === WebSocket.OPEN) &#123; //Socket open, send ws.send(e); &#125; else &#123; //Show an error, queue it for sending later, etc &#125;&#125; close() 123ws.close();//or pass a numeric code and human-readable stringws.close(100, &quot;Goodbye, World!&quot;); WebSocket close()方法状态码https://developer.mozilla.org/zh-CN/docs/Web/API/CloseEvent WebSocket 属性当open事件触发后，WebSocket对象会有几个属性可以被客户端应用读取。 readyState| 属性名| 值| 描述|| :——– | ——–:|:– || WebSocket.CONNECTING| 0 | 连接还未打开|| WebSocket.OPEN| 1 | 连接已打开并准备通信|| WebSocket.CLOSING | 2 | 正在关闭连接 || WebSocket.CLOSED | 3 | 连接已关闭 | bufferedAmount常用于发送二进制数据，确保在连接关闭前所有数据已经发送或者在客户端执行某些限制 protocol服务器端所采用的子协议（在使用WebSocket构造器时指定的protocol参数，如果服务器没有采用则为空） 更多WebSocket详细信息参考MDN的WebSocket API]]></content>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS Grid]]></title>
    <url>%2F2018%2F01%2F07%2FCSS-Grid%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[(译)JavaScript的开销]]></title>
    <url>%2F2017%2F12%2F05%2FThe-cost-of-JavaScript%2F</url>
    <content type="text"><![CDATA[当我们建立严重依赖于JavaScript的网站时，我们不总是很容易看到我们发送的内容所付出的代价。在这篇文章中，如果你希望你的网站在移动设备上能够快速加载和互动，我将介绍为什么一些规则可以帮助你。 tl;dr：较少的代码=较少的解析/编译+较少的传输+较少的解压缩 网络当大多数开发人员考虑JavaScript的成本时，他们会考虑下载和执行成本。通过线路发送更多字节的JavaScript需要的时间越长，用户的连接也就越慢。 这可能是一个问题，即使在发达国家，因为用户有效的网络连接类型可能实际上并不是3G，4G或WiFi。你可能在咖啡店使用Wifi，但连接到的是2G的蜂窝热点。 您可以通过以下方式降低 JavaScript的网络传输成本： 只发送用户需要的代码。代码拆分这时候就有用武之地了。 压缩代码（ES515的 Uglify， ES2015的 babel- minify或uglify -es） 高度压缩（使用Brotli〜q11，Zopfli或gzip的）。Brotli的压缩比超过Gzip。它让CertSimple节省了17％的JS压缩字节大小，LinkedIn节省了 4％的加载时间。 删除未使用的代码。通过DevTools代码覆盖来确定。对于剥离的代码，可以查看tree shaking，闭包编译器的高级优化和微调库插件如lodash-babel-plugin插件或WebPack的ContextReplacementPlugin如Moment.js库。使用babel-preset-env和browserlist来避免现代浏览器中已经存在的转译功能。高级开发人员可能会发现仔细分析Webpack捆绑包有助于识别修剪不需要的依赖关系。 使用HTTP缓存以尽量减少网络跳转。确定脚本的最佳生命周期（max-age）和提供令牌验证（ETag）以避免传输没有变更的字节。Service Worker缓存可以使您的应用程序网络具有弹性，让您可以快速访问V8的代码缓存等功能。了解有关文件名哈希的长期缓存。 解析/编译一旦JS下载完毕，JavaScript最大的一个成本就是JS引擎解析/编译这段代码的时间。在Chrome DevTools中，解析和编译是“性能”面板中黄色“脚本”时间的一部分。 Bottom-Up/Call Tree允许查看确切的解析/编译时序：Chrome DevTools“性能”面板&gt;自下而上。通过启用V8的运行时调用统计，我们可以看到分析和编译阶段花费的时间 但是，为什么这会有问题呢？花费很长时间解析/编译代码会严重延迟用户与网站互动的时间。发送的JavaScript越多，在网站交互之前解析和编译的时间就越长。 同样多的字节，浏览器处理JavaScript要比同等大小的图像或Web字体开销更大。 - Tom Dale 与JavaScript相比，在处理等效大小的图片时（涉及到大量的图片仍然需要解码！），涉及到大量的开销，但是在一般的移动设备上，JS更有可能对页面的交互性产生负面影响。JavaScript和图像字节的开销有很大的不同。图像通常不会阻塞主线程，也不会阻止接口在解码和栅格化时进行的交互。然而JS由于解析，编译和执行的成本会延迟交互性。 当我们谈论解析和编译变慢的时候，上下文很重要 - 我们在这里谈论的普通手机。指的是大部分用户使用的CPU和GPU速度较慢的手机，无L2 / L3缓存，甚至可能内存很小。 网络功能和设备功能并不总是相匹配。使用光纤连接的用户不一定有最好的CPU来解析和执行发送到他们的设备的JavaScript。反过来也是如此。一个糟糕的网络连接，但却有一个快速的CPU。 - Kristofer Baxter，LinkedIn 在JavaScript启动性能中，我注意到在低端和高端硬件上解析大约1MB已经被解压的（简单）JavaScript的开销。在市场上最快的手机和普通手机之间解析/编译代码的时间有2-5倍的差异。在不同类别的桌面和移动设备上解析一个1MB的JavaScript包（约有250KB 被gzip压缩了）的解析时间。在查看解析的开销时，解压后的数据要考虑到大约有250KB 被gzip压缩的空间会被释放出来当解压缩大约1MB的代码的时候 那么现实世界的网站如何呢，如CNN.com在高端的iPhone 8上，解析/编译CNN的JS需要花费大约4秒，而普通手机（Moto G4）则只需要13秒。这可以显著影响用户与本网站完全交互的速度。苹果的A11仿生芯片和非常普通的Android硬件中的Snapdragon 617的解析时间性能比较。 这突出了普通硬件（如Moto G4）测试的重要性，而不仅仅是口袋里的手机。但是，使用环境很重要：优化您的用户拥有的设备和网络条件。 分析可以深入了解您的真实用户访问您的网站的移动设备类别。这可以提供机会来了解他们正在使用的真正的CPU / GPU的限制。 我们是否真的发送了太多的JavaScript？错误，这很有可能:) 使用HTTP Archive（最高大约50万个站点）来分析移动设备上JavaScript的状态，我们可以看到，50％的站点需要14秒才能获得交互。仅仅只是解析和编译JS，这些网站就花费长达4秒。 在获取和处理JS和其他资源所花费的时间中，因为感觉网页已经可以使用，用户可能会等待一段时间，这也许并不奇怪。但我们一定可以在这里做得更好。 从网页中删除不重要的JavaScript可以减少传输时间，CPU密集型解析和编译以及潜在的内存开销。这也有助于让您的网页更快地交互。 执行时间这不仅仅是解析和编译，而且可能会带来额外的开销。JavaScript执行（一次解析/编译运行代码）是在主线程上发生的操作之一。很长的执行时间也可以推出用户可以与网站互动的时间。 如果脚本执行时间超过50ms，则交互时间会被下载，编译和执行JS所花时间延迟了 - Alex Russell 为了解决这个问题，JavaScript受益于small chunks，以避免锁定主线程。探索是否可以减少执行过程中正在进行的工作量。 减少JavaScript发送开销的模式当你试图保持JavaScript的解析/编译和网络传输时间很慢时，有一些模式可以帮助像基于路由的分块(route-based chunking)或PRPL。 PRPL是一种通过代码分割和缓存来优化交互性的模式： 让我们看看它可以产生的影响。我们使用V8的运行时调用统计来分析流行移动网站和Progressive Web Apps的加载时间。正如我们所看到的，解析时间（以橙色显示）是许多这些站点花费时间的比较大的部分： Wego是一个使用PRPL的网站，它设法保持较低的路由解析时间，能够非常迅速地进行互动。上面的许多其他站点都采用代码分解和性能预算来降低JS的开销。 其他开销JavaScript可以通过其他方式影响页面性能： 内存。由于GC（垃圾收集），页面可能经常会出现卡顿或暂停。当浏览器回收内存时，JS执行被暂停，所以经常进行垃圾收集的浏览器可以比我们想要的更频繁地暂停执行。避免内存泄漏和频繁的gc暂停，以保持页面流畅。 在运行时，长时间运行的JavaScript可以阻止主线程导致无响应的页面。将工作分成更小的部分（使用requestAnimationFrame（）或有计划的使用requestIdleCallback（））可以最大限度地减少响应性问题。 渐进式引导许多网站将内容可视性作为交互性的代价来优化。为了在有大的JavaScript包时获得一个快速的首页，开发者有时会使用服务器端渲染;然后在JavaScript最终获取时将其“升级”以附加事件处理程序。 小心 - 这有它自己的开销。1）这通常会发送一个更大的 HTML响应，这会延迟交互性，2）这会把用户留在一个离奇的山谷中，其中有一半的实际功能是没有办法交互的，直到JavaScript运行完成。 渐进式引导可能是一个更好的方法。发送一个最小功能的页面（由当前路由所需的HTML / JS / CSS组成）。随着更多的资源到达，该应用程序可以延迟加载和解锁更多的功能。Paul Lewis的渐进式引导视觉 根据所看到的加载代码是圣杯。PRPL和渐进引导是可以帮助实现这一点的模式。 结论传输大小对低端网络至关重要。解析时间对于CPU受限的设备很重要。保持这两者的抵开销。 团队发现成功采用严格的性能预算来保持JavaScript传输和解析/编译时间较短。请参阅Alex Russell的“ 您可以承受吗？：真实世界的Web性能预算 ”，以获取关于移动预算的指导。考虑一下我们制作的架构决策可以为应用程序逻辑留下多少JS“空间”。 如果您正在构建针对移动设备的网站，请尽可能在代表性硬件上开发，保持较低的JavaScript分析/编译时间，并采用性能预算来确保您的团队能够关注其JavaScript成本。 注： 本文版权归原作者所有，仅用于学习与交流； 如需转载译文，烦请按下方注明出处信息，谢谢！原文： The Cost Of JavaScript作者： Addy Osmani译者：smallbone原文地址]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>翻译</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了不起的NodeJS：MongoDB代码更正]]></title>
    <url>%2F2017%2F10%2F01%2Fsmashingnode-master-code%2F</url>
    <content type="text"><![CDATA[最近在学习NodeJS，在网上一番搜索资料后，很多人都建议读《了不起的NodeJS》，于是就开始开始啃起来了。在一边读一边敲代码的的过程中发现书中有些示例中的代码存在书写或者框架的更新导致运行出错，花了不少时间学习框架的更新和库的使用方法，才让代码运行正常。下面就是有关MongoDB代码更正： express实例创建书上的写法1var app = express.createServer(); 更新后的写法1var app = express(); 中间件书上的写法1234//源代码app.use(express.bodyParser());app.use(express.cookieParser());app.use(express.session(&#123;secret: &apos;my secret&apos;&#125;)); 由于新版的express中将原来自身的大部分中间件都移除了，所以需要额外安装并引用。123456789//更正后var session = require(&apos;express-session&apos;);var cookieParser = require(&apos;cookie-parser&apos;);var bodyParser = require(&apos;body-parser&apos;);app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: true &#125;));app.use(cookieParser());app.use(session(&#123;secret: &apos;my secret&apos;&#125;)); bodyParser.urlencoded中的extented设置选项是用来控制POST传递的值是放能被对象化，例如下面的jade模板中input信息1input(name=&quot;user[first]&quot;, type=&quot;text&quot;) { extended: true }: req.body 为 { user: { name: ‘123123’ } }{ extended: false }: req.body 为 { ‘user[name]’: ‘12313’ } Jade模板Jade模板已经更名为Pug，但是仍然可以使用jade。 doctype的变更： doctype 5 =&gt; doctype html 书中index模板中的block body下的代码应该缩进1234567891011//更正后extends layoutblock content if (authenticated) p Welcome back, #&#123;me.first&#125; a(href=&quot;/logout&quot;) Logout else p Welcome new visitor! ul li: a(href=&quot;/login&quot;) Login li: a(href=&quot;/signup&quot;) Signup mongodb新建collection12//源代码app.users = new mongodb.Collection(client, &apos;users&apos;); 这里 Collection 是 mongodb 的方法得用小写,另外在使用 mongodb 之前记得要先用 mongod 命令开启服务器12//更正后app.users = new mongodb.collection(client, &apos;users&apos;); mongodb insert 后的回调使用123456//源代码app.users.insert(req.body.user, function (err, doc) &#123;if (err) next(err);console.log(doc);res.redirect(&apos;/login/&apos; + doc[0].email);&#125;); doc 变成了一个对象，拥有 result 和 ops 两个属性,我们需要的数据在 ops 里面12345app.users.insert(req.body.user, function (err, doc) &#123;if (err) next(err);console.log(doc);res.redirect(&apos;/login/&apos; + doc.ops[0].email);&#125;); 204页忘记传 next 了…12345678//源代码app.post(&apos;/login&apos;, function (req, res) &#123;app.users.findOne(&#123;email: req.body.email, password: req.body.password&#125;, function (err, doc) &#123;if (err) return next(err);if (!doc) return res.send(&apos;&lt;p&gt;User not found &lt;/p&gt;&apos;);req.session.loggedIn = doc._id.toString();&#125;);&#125;); 12345678//更正后app.post(&apos;/login&apos;, function (req, res, next) &#123;app.users.findOne(&#123;email: req.body.email, password: req.body.password&#125;, function (err, doc) &#123;if (err) return next(err);if (!doc) return res.send(&apos;&lt;p&gt;User not found &lt;/p&gt;&apos;);req.session.loggedIn = doc._id.toString();&#125;);&#125;); mongodb的_id查询使用 mongodb 的 _id 进行查询,原文中的指代方法已经不能使用了。而 node 本身不提供生成 objectid 的方法这里需要依赖第三方工具12345//源代码app.users.findOne(&#123;_id: &#123;$oid: req.session.loggedIn&#125;&#125;, function (err, doc) &#123;if (err) return next(err);next();&#125;); 1234567//更正后var objectid = require(&apos;objectid&apos;);app.users.findOne(&#123;_id: objectid(req.session.loggedIn)&#125;, function (err, doc) &#123;if (err) return next(err);next();&#125;); jade中全局变量 locals 的使用1234567891011121314//源代码app.use(function (req, res, next) &#123;if (req.session.loggedIn) &#123;res.local(&apos;auth&apos;, true);app.users.findOne(&#123;_id: objectid(req.session.loggedIn)&#125;, function (err, doc) &#123;if (err) return next(err);res.local(&apos;me&apos;, doc);next();&#125;);&#125; else &#123;res.local(&apos;auth&apos;, false);next();&#125;&#125;); 这里 express 的定义方法更改了,另外使用 mongodb 查询的时候如果没有查找到并不会报错,而是在回调的 doc 设为 null。 1234567891011121314//更正后app.use(function (req, res, next) &#123;if (req.session.loggedIn) &#123;app.locals.auth = true;app.users.findOne(&#123;_id: objectid(req.session.loggedIn)&#125;, function (err, doc) &#123;if (err) return next(err);if (doc) app.locals.me = doc;next();&#125;);&#125; else &#123;app.locals.auth = false;next();&#125;&#125;);]]></content>
      <tags>
        <tag>Node</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的Sets简介]]></title>
    <url>%2F2017%2F07%2F16%2FSets-in-JavaScript%2F</url>
    <content type="text"><![CDATA[Sets 是ES6(ES2015)中一个新的对象类型，用来创建一系列唯一值的集合.集合中的值可以是简单的原始类型如字符串(strings)或整数(integers)，也可以是更复杂的对象类型如对象字面量或者数组 基本方法下面是基本的set及其方法(add, size, has, forEach, delete, clear)的简单示例： 12345678910111213141516171819202122232425let animals = new Set();animals.add('🐷');animals.add('🐼');animals.add('🐢');animals.add('🐿');console.log(animals.size); // 4animals.add('🐼');console.log(animals.size); // 4console.log(animals.has('🐷')); // trueanimals.delete('🐷');console.log(animals.has('🐷')); // falseanimals.forEach(animal =&gt; &#123; console.log(`Hey $&#123;animal&#125;!`);&#125;);// Hey 🐼!// Hey 🐢!// Hey 🐿!animals.clear();console.log(animals.size); // 0 初始化下面是另一个将数组作为初始值传进set的示例。需要主要的是初始化的数组是如何被解构的，但是随后添加的数组将以数组的形式存在： 123456789101112131415let myAnimals = new Set(['🐷', '🐢', '🐷', '🐷']);myAnimals.add(['🐨', '🐑']);myAnimals.add(&#123; name: 'Rud', type: '🐢' &#125;);console.log(myAnimals.size); // 4myAnimals.forEach(animal =&gt; &#123; console.log(animal);&#125;);// 🐷// 🐢// ["🐨", "🐑"]// Object &#123; name: "Rud", type: "🐢" &#125; 字符串也是一个有效的迭代，所以也可以被传入来初始化一个set： 1234console.log('Only unique characters will be in this set.'.length); // 43let sentence = new Set('Only unique characters will be in this set.');console.log(sentence.size); // 18 For…of遍历除了在一个set上可以使用forEach外，for…of循环也可以被用来遍历sets： 12345678910let moreAnimals = new Set(['🐺', '🐴', '🐕', '🐇']);for (let animal of moreAnimals) &#123; console.log(`Howdy $&#123; animal &#125;`);&#125;// Howdy 🐺// Howdy 🐴// Howdy 🐕// Howdy 🐇 Keys 和 ValuesSets也有keys和values方法，由于keys是values的别名，所以两个方法其实是完成一样的事情。使用两者中的任何一个方法都会返回一个新的可迭代的对象，该对象的值与添加到集合中的顺序相同。 123456789101112131415161718192021222324let partyItems = new Set(['🍕', '🍾', '🎊']);let items = partyItems.values();console.log(items.next());console.log(items.next());console.log(items.next());console.log(items.next().done);// Object &#123;// done: false,// value: "🍕"// &#125;// Object &#123;// done: false,// value: "🍾"// &#125;// Object &#123;// done: false,// value: "🎊"// &#125;// true 注： 本文版权归原作者所有，仅用于学习与交流； 如需转载译文，烦请按下方注明出处信息，谢谢！原文： Introduction to Sets in JavaScript作者： alligatorio译者：smallbone译文地址：https://alligator.io//js/sets-introduction/]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Sets</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex Basis与Width的区别]]></title>
    <url>%2F2017%2F07%2F08%2FWidth-FlexBasis%2F</url>
    <content type="text"><![CDATA[最近在学习Flex Box，其中的Flex Box属性中的Flex Basis是关于项目宽度属性设置的，这让许多初学Flex Box的人困惑它与CSS盒子模型Width属性的区别在哪？Google了一番，找到一篇解释写得很是不错的文章，尝试着翻译分享一下。原文地址：http://gedd.ski/post/the-difference-between-width-and-flex-basis/ Flex Items的应用准则content –&gt; width –&gt; flex-basis (limted by max|min-width)也就是说， 如果没有设置flex-basis属性，那么flex-basis的大小就是项目的width属性的大小 如果没有设置width属性，那么flex-basis的大小就是项目内容(content)的大小 下面通过给一个1000px的flex容器来添加一些flex items来说明一下Flex Items的应用准则：1234container &#123; display: flex; width: 1000px;&#125; 设置宽度(Width)添加四个200x200像素的items到flex容器中1234item &#123; width: 200px; height: 200px;&#125; 因为flex容器有足够多的空间，所以items可以很好的填充在容器内部：上面的示例就是当flex-basis没有被指定，默认值是flex-basis: auto，也就意味着items以宽度width(200px)为准。 设置一个Flex Basis值让我们看看当给这些已经设置固定宽度width的items设置一个flex-basis值会发生什么。1234item &#123; width: 30px; flex-basis: 250px;&#125; 就像你说看到的，当指定一个flex-basis值的时候，盒子的宽度属性被忽略了，所以我们就不需要指定盒子的宽度width属性了123item &#123; flex-basis: 250px;&#125; items完全填充了flex容器：因此items的宽度关键在用最终的flex-basis。最佳的方法是只使用flex-basis而不是width或height属性。特别是Safari 10之前的版本的浏览器有一个flexbox bug，在给items应用flex-shrink属性的时候，浏览器会使用height属性而不是flex-basis。 使用max-width来限制flex-basismin-width和max-width会限制flex-basis值。下面是给flex items设置max-width的结果：1234item &#123; flex-basis: 250px; max-width: 100px;&#125; 可以看到即使我们将flex-basis设置为250px，item的宽度还是被限制在了100px。所以在这个示例中最终的flex-basis是100px：接着试试min-width来看看最终的flex-basis有什么不同：1234item &#123; flex-basis: 100px; min-width: 250px;&#125; 可以看到最终item的宽度是250px而不是100px： Flex-basis到底是什么？现在我们知道了width属性只是一个当flex-basis没有被设置时的回退选项。min-width和max-width则是flex-basis的下限和上限。那么flex-basis到底是什么呢？ 也许你注意到了上面我们所有的示例在将flex items放入flex容器之前都直观地列出了flex items的大小。之所以这么做是因为这就是flex-basis的含义：flex items 在被放进一个flex容器之前的大小。也就是items理想或假设的大小。但是flex-basis不能保证其大小！一旦将items放入flex容器中，flex-basis的值就无法保证了。在上面的示例中，你可以看到flex items完美地填充了容器，那是因为容器的大小正好等于items最终的flex-basis之和。但是如果容器没有足够的空间来容纳或者有多余的空间呢？下面就分别讲解一下这两种情况： 当没有足够空间的时候比方说我们想要放更多的flex-basis：200px的items到我们的容器：在items被放进容器之前，每个item会占据200px，所有的items会占据1600px。但是容器只有1000px。当容器没有足够大的空间来存放所有的items的时候，flex items会按照压缩率(shrink rate)被压缩(shrink)其大小来填充容器,这个压缩率就是flex-shrink来设置的，默认情况下每个item的压缩率都是一样的： 当有额外的空间的时候通常我们会有额外的空间剩余当所有的items都添加进容器后：123item &#123; flex-basis: 100px;&#125; 我们可以控制flex items的增长来填充可用的空间，这也就是flex-grow属性的作用。默认值为0，意味着item不会增长。如果将每个item设置flex-grow： 1，那么所有 的item都会等比例的增长来填充剩余的空间：1234item &#123; flex-basis: 100px; flex-grow: 1;&#125; 增长和压缩是flexbox中很重要的特性，也让flexbox非常适合应用于响应式UI设计。Flexbox Zombies课程涵盖了flex-shrink和flex-grow更多详细的细节。 Width vs flex-basis希望现在你明白了width和flex-basis之间的区别，也知道了如何使用min-width和max-width来限制最终的flex-basis。以上这些设置同样适用于height属性，当你将flex-direction设置为column或者column-reverse的时候。如果你想掌握所有的flexbox属性，墙裂推荐免费的Flexbox Zombies课程，通过玩游戏来学习flexbox！]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>FlexBox</tag>
        <tag>翻译</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
</search>