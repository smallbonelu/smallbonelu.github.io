<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[(译)HTTP/2的优先级]]></title>
    <url>%2F2018%2F12%2F29%2FHTTP2-Prioritization%2F</url>
    <content type="text"><![CDATA[以正确的顺序请求页面资源对于快速的用户体验至关重要。想象一下，如果一个网页上有一堆图片，还有一个外部样式表，一些自定义Web字体和一些在head中的脚本。如果浏览器首先下载了所有图片并且最后加载了样式表，在所有内容都加载完毕前，页面将完全是空白页。如果浏览器首先加载了所有阻塞资源，接着是Web字体和图片，那么它可以更早地呈现页面，并让用户开始看到内容，同时加载其余的图片。我在Chrome浏览器性能工作上的大部分时间都花在了尝试优化加载资源的顺序以获得最佳用户体验上。 使用HTTP/1.x，浏览器可以完全控制资源加载顺序。每个连接一次只能支持一个资源请求，服务器会尽快返回请求的内容。浏览器可以通过决定何时请求资源以及打开多少个并行连接来安排请求。 HTTP/2让这些事情变得更好也更复杂了。浏览器可以一次请求多个资源，指定一些优先级信息来帮助确定应该如何处理这些资源，然后等待服务器发回所有数据，而不是一次请求一个。如果浏览器和服务器都支持优先级，则应使用浏览器指定的规则并使用所有可用带宽来传递资源，而不会有资源之间的相互竞争。 每个资源都获取一个stream ID来标识连接上的资源，并且有三个参数用于定义资源优先级： 父级数据流(Parent Stream)：这个数据流是一个“依赖”资源或者应该在之后被传递的数据流。有一个所有数据流共享的虚拟root stream 0。 权重(Weight)：1到256之间的数字，用于标识在多个数据流共享连接时分配给此数据流的带宽量。带宽是相对于所有其他活动的数据流的权重分配的，而不是绝对值。 独占位(Exclusive bit)：一个标志，表示应该在不与任何其他数据流共享带宽的情况下下载。 浏览器不一定同时知道所有资源，因此服务器能够在新请求到达时重新确定请求的优先级也很关键。 那么……我们是怎么做的呢？ 浏览器引擎Chrome这包括使用Chromium的优先级逻辑和网络堆栈的所有内容。 Chrome是唯一使用独占位的浏览器，它在每个资源上使用它。它构建了一长串资源，将较低优先级的资源链接到仍在等待的最后一个相同或更高优先级的资源。如果没有更高优先级的资源挂起，则启动新链。权重以静态映射的方式分配，Chrome的五个内部优先级分别对应相应的权重（即HIGHEST为256）。 假设给定几个请求队列，所有请求都设置了独占位，服务器将选择权重最高的一个，完成传递后，就将其从列表中弹出并重新选择。 假设Chrome正确构建了排序，这可能非常有效。独占下载资源是样式表和脚本等阻塞资源的最佳选择。当涉及到图片和视频时，你可能需要一些交错执行的任务（特别是对于渐进式图片）。否则，在转到下一个请求前，你将要等待每个图片或视频完全下载下来。 FirefoxFirefox实现了HTTP/2的树结构，并构建了一个虚拟的数据流树，用来对不同请求类型进行分组。Firefox对分组进行了加权，以便为更重要的组提供更多的带宽，并且当所有节点都已完成时，空闲周期(idle cycles)可用于响应。 在根级别中，有一个“leader”组，，它的带宽是“Other group”的两倍。在“leader”组中，有一个叫“follower”的子组，它只有在“leader”组的直系后代完成下载后才会开始下载。例如，在权重为200的“leader”组下面，一旦所有CSS完成下载后，图片和字体才会开始下载。一个组内的所有子资源具有相同的权重并均匀分配带宽（同时下载所有图片或所有脚本）。 从整体结构上来看Firefox非常出色，可以为推测请求定义空闲周期，但对同时下载所有资源优先级的划分并不是很好。像样式表和脚本等这样的阻塞资源的优先下载要比按顺序下载它们才能让解析器处理文档要好。 Safari这包括iOS上的所有浏览器（包括Chrome）。 Safari采用了一种非常简单的方法，看起来是SPDY优先级的遗留部分。五个内部webkit优先级静态映射到权重，并且没有定义依赖关系。所有请求基于每个资源的优先级来划分带宽权重进行同时下载（例如，脚本获得图片带宽的三倍）。 这样导致高并发性并不是很好，而且落后于Firefox的实现，在Firefox中至少follower组的资源会等到leader组资源全部完成任务之后（尽管它可能不足以证明Firefox中树的复杂性）。 Microsoft Edge / Internet Explorer简而言之，Microsoft Edge（和Internet Explorer）根本不支持优先级。所有请求均匀分配带宽（几乎是最糟糕的情况）。 Servers/Hosting/CDNs现在大多数服务器都支持HTTP/2了，通常也”支持”优先级的。支持加了引号，是因为即使一个服务器内部支持资源优先级，实际上让它能够与浏览器工作也需要调整网络堆栈并尽可能减少输出缓冲而不影响吞吐量。 缓冲可能是一个问题，因为服务器可以发送一堆低优先级的响应，这些响应在高优先级响应到来之前已经在缓冲区中排队。发送高优先级响应时，无法抢占已缓冲的低优先级响应。缓冲可以来自服务器本身，TLS层，TCP发送的缓冲，甚至来自网络上的bufferbloat，跟踪并消除所有多余的缓冲可能会很复杂。我在今年早些时候的一篇博文中谈到了一些原因和解决方案，但这并不是一个详尽的清单。 为了测试服务器优先级的有效性，我构建了一个测试页面，你可以在你的服务堆栈上部署该测试页面以查看优先级是否正常工作。它专门针对Chrome的优先级逻辑，因此最好使用慢速连接上的Chrome进行测试。它先将3MB低优先级图片排队，然后在下载并执行高优先级脚本后，脚本会发送4个高优先级请求（一张图片，一个页面背景，一个自定义的webfont和一个阻塞脚本）。当优先级正常工作时，后置的高优先级请求的资源会跳过低优先级请求并快速得到响应： 当优先级工作不正常时，部分或全部后置的高优先级请求的资源会被延迟，直到优先级较低的请求完成为止： 后置请求的阻塞脚本的延迟超出了“DOM Content Loaded”的度量值，字体和2个图片的延迟对视觉体验产生了相当大的影响： 我们从哪里开始？为了跟踪CDN和托管服务提供商支持HTTP/2优先级的程度，Andy Davies创建了一个GitHub仓库，用于跟踪当前的支持状况，任何人都可以提交测试结果来群策群力。在撰写本文时，情况非常糟糕，只有两个CDN确实正确地确定了优先级，并且存在一些非常令人震惊的失败（例如每个云提供商甚至Google的GFE）。希望通过提高对这种情况的认知，我们将能够为优先级提供更广泛的支持。 对托管和服务器来说，好消息是你总是可以在它们之前配置一个支持优先级的CDN来解决问题（尽管直接支持它会很好）。 在浏览器方面，除了敦促浏览器厂商以获得更好的支持之外，没有太多可以做的事情。其中的一些厂商可能会遇到架构问题，如他们的浏览器引擎在操作系统的网络堆栈层之上，导致无法传递优先级信息。可能是我的偏见，但我认为Chrome是最接近“正确”的做法，但仍有相当大的改进空间。 HTTP/3也即将到来，但目前的优先级方案不会改变。这个改变是网络堆栈的终结。在服务器端，这意味着操作系统的缓冲和拥塞控制不再起作用，服务器软件100％负责最小化缓冲（包括拥塞控制算法以最小化缓冲区）。 那么就说到这里，希望为了HTTP/2和一个安全，高性能的网络，我们可以在2019年修复资源优先级。 本文版权归原作者所有，仅用于学习与交流； 如需转载译文，烦请按下方注明出处信息，谢谢！ 原文地址：HTTP/2 Prioritization原文作者：[Patrick Meenan]译者：smallbonelu]]></content>
      <tags>
        <tag>HTTP/2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中对象的拷贝]]></title>
    <url>%2F2018%2F12%2F13%2FCopying-Objects-in-JavaScript%2F</url>
    <content type="text"><![CDATA[浅拷贝利用for循环遍历原始对象将原始对象中的每个属性拷贝到目标对象上，但是可能存在性能问题 12345678910111213141516171819202122function shallowCopy(sourceObj) &#123; let objCopy = &#123;&#125;; let key; for (key in sourceObj) &#123; if (sourceObj.hasOwnProperty(key)) &#123; objCopy[key] = sourceObj[key]; &#125; &#125; return objCopy;&#125;const sourceObj = &#123; a: 3, b: 5, c: &#123; x: 7, y: 9 &#125;&#125;console.log(shallowCopy(sourceObj)); 使用Object.assign()方法1234567let obj = &#123; a: 1, b: 2&#125;let objCopy = Object.assign(&#123;&#125;, obj);console.log(objCopy); 使用ES6的扩展运算符...123456let obj = &#123; one: 1, two: 2&#125;let newObj = &#123;...obj&#125;; 浅拷贝存在的问题 拷贝对象的原型链不会继承原始对象的原型链 原始对象的属性描述符(数据属性，访问器属性)不会被拷贝 只拷贝了可枚举的属性 原始对象中内嵌的对象与拷贝后对象中的内嵌对象共享内存地址 深拷贝使用JSON.parse(JSON.stringify(object))它能正确处理的对象只有 Number, String, Boolean, Array 扁平对象，即那些能够被JSON直接表示的数据结构，比如Date对象就不适用此方法。 123456789101112let obj = &#123; a: 1, b: &#123; c: 2 &#125;&#125;let newObj = JSON.parse(JSON.stringify(obj));obj.b.c = 20;console.log(obj); // &#123;a: 1, b: &#123;c: 20&#125;&#125;console.log(newObj); // &#123;a: 1, b: &#123;c: 2&#125;&#125; 缺点： 无法拷贝用户定义的对象方法(函数)，但是Object.assign()方法可以 JSON.parse(JSON.stringify(object))方法无法拷贝环对象(环对象指的是对象本身的属性之间相互引用)，但是Object.assign()方法却可以浅拷贝循环引用的对象 使用第三方库如Underscore的_.clone()，jQuery的$.clone()浅拷贝 / $.extend(true, {}, ...)可以实现深复制，lodash的_.clone() / _.cloneDeep()，其中lodash的兼容性更好一些 利用HTML5的history API利用history.pushState()和history.replaceState()两个方法都会为它们的第一个参数创建一个结构化的克隆，不过要注意的是因为这两个方法是同步的并且对浏览器历史记录的操作性能并不是很高，所以重复调用这两个方法可能会导致浏览器没有响应，影响用户体验 1234567const structuredClone = obj =&gt; &#123; const oldState = history.state; history.replaceState(obj, null); const cloneObj = history.state; history.replaceState(oldState, null); return cloneObj;&#125; 利用Notification API当利用Notification构造函数创建通知时，构造函数也会为传入的数据创建一个结构化的克隆 12345const structuredClone = obj =&gt; &#123; const n = new Notification("", &#123;data: obj, slient: true&#125;); n.onshow = n.close.bind(n); return n.data;&#125; 使用Node.JSNode.js自8.0.0版本之后提供了一个兼容结构化克隆的序列化API，但是这个API还在开发阶段，所以兼容性并不是很好 1234const v8 = require('v8');const buf = v8.serialize(&#123;a: 'foo', b: new Date()&#125;);const cloned = v8.deserialize(buf);cloned.b.getMonth(); 原生方法stackoverflow上原生Javascript实现的一个简单的对象克隆函数： 123456789101112131415161718192021222324252627282930313233function clone(obj) &#123; var copy; // Handle the 3 simple types, and null or undefined if (null == obj || "object" != typeof obj) return obj; // Handle Date if (obj instanceof Date) &#123; copy = new Date(); copy.setTime(obj.getTime()); return copy; &#125; // Handle Array if (obj instanceof Array) &#123; copy = []; for (var i = 0, len = obj.length; i &lt; len; i++) &#123; copy[i] = clone(obj[i]); &#125; return copy; &#125; // Handle Object if (obj instanceof Object) &#123; copy = &#123;&#125;; for (var attr in obj) &#123; if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]); &#125; return copy; &#125; throw new Error("Unable to copy obj! Its type isn't supported.");&#125; 总结深拷贝和浅拷贝区别：浅拷贝只复制一层对象的属性，而深拷贝则递归复制了所有层级深拷贝必须用到递归。从兼容性方面考虑，使用lodash的cloneDeep()是最佳的选择。 参考链接：Copying Objects in JavaScriptjavascript中浅拷贝和深拷贝的区别深入剖析 JavaScript 的深复制COPYING OBJECTS IN JAVASCRIPT]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BeautifulSoup4 find_all搜索包含指定文本内容的标签返回空list的问题]]></title>
    <url>%2F2018%2F08%2F30%2FBeautifulSoup4%E6%90%9C%E7%B4%A2%E5%8C%85%E5%90%AB%E6%8C%87%E5%AE%9A%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%E7%9A%84%E6%A0%87%E7%AD%BE%E8%BF%94%E5%9B%9E%E7%A9%BAlist%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近帮助公司其他团队用python写了一个爬虫，遇到了不少问题，其中就有一个问题是使用BeautifulSoup4的find_all搜索包含指定文本内容时返回的是空的list，查看了官方文档也上google搜索了一些类似的问题，发现是因为在使用bs4的find_all结合正则表达式查找指定文本的时候，搜索的是bs4返回元素中string属性中的信息，而不是text属性。并且如果某个元素中如果还包含除了文本之外的子元素，string属性返回会是None，而不是像text属性中那样的文本信息。 如果HTML中的内容结构像下面这样:1234&lt;td&gt;some text&lt;/td&gt; &lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;more text&lt;/p&gt;&lt;/td&gt;&lt;td&gt;even &lt;p&gt;more text&lt;/p&gt;&lt;/td&gt; td 上的.string属性将会返回下面的内容：1、some text2、None3、more text4、None .text 属性将会返回下面的内容：1、some text2、3、more text4、even more text 如果想要了解.find和.string之间的差异可以查看Python BeautifulSoup 中.text与.string的区别 解决办法是使用lambda函数12&gt;&gt;&gt; soup.find_all(lambda e: e.name == &apos;td&apos; and &apos;Black&apos; in e.text)[&lt;td id=&quot;rp10&quot; valign=&quot;top&quot;&gt;Black or African American alone, percent, 2013 (a) &lt;!-- RHI225213 --&gt; &lt;/td&gt;, &lt;td id=&quot;re6&quot; valign=&quot;top&quot;&gt;Black-owned firms, percent, 2007 &lt;!-- SBO315207 --&gt; &lt;/td&gt;]]]></content>
      <tags>
        <tag>BeautifulSoup4</tag>
        <tag>python爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何解决公网无法访问阿里云ECS搭建的MongoDB服务]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%85%AC%E7%BD%91%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E9%98%BF%E9%87%8C%E4%BA%91ECS%E6%90%AD%E5%BB%BA%E7%9A%84MongoDB%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[最近为了学习后端购买了一台阿里云ECS云服务器（专用网络）环境如下：OS：Ubuntu16.04，MongoDB：v4.0.1 尝试着安装了MongoDB并进行了相应的配置，搜索了一些资料发现关键在于三点： MongoDB的bindIp配置： MongoDB默认的配置文件中，bindIp选项默认是localhost，也就是说默认只有安装了MongoDB的主机自己能够访问。所以如果需要外网的主机能够访问MongoDB服务，首先需要更改bindIp选项，将其设置为指定的IP地址(x.x.x.x, …)者绑定所有的IP地址(0.0.0.0 )。MongoDB 3.6之后的版本新增了bindIpAll选项，true代表绑定所有IP地址。 配置文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142# mongod.conf# for documentation of all options, see:# http://docs.mongodb.org/manual/reference/configuration-options/# Where and how to store data.storage: dbPath: /var/lib/mongodb journal: enabled: true# engine:# mmapv1:# wiredTiger:# where to write logging data.systemLog: destination: file logAppend: true path: /var/log/mongodb/mongod.log# network interfacesnet: port: 27017 bindIpAll: true # how the process runsprocessManagement: timeZoneInfo: /usr/share/zoneinfo#security:#operationProfiling:#replication:#sharding:## Enterprise-Only Options:#auditLog:#snmp: Linux防火墙iptables的配置： 在bash中输入sudo iptables -A INPUT -p tcp --destination-port 27017 -m state --state NEW,ESTABLISHED -j ACCEPTsudo iptables -A OUTPUT -p tcp --source-port 27017 -m state --state ESTABLISHED -j ACCEPT 开放MongoDB的端口。 接着输入iptables-save和 iptables-restore保存iptables的配置信息以免主机重启后需要重新配置。 ECS主机的安全组规则配置： 经过以上的配置后，就能够远程连接阿里云ECS上搭建的MongoDB服务了。]]></content>
      <tags>
        <tag>MongoDB</tag>
        <tag>Ubuntu</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(译)7个ES6编程小技巧]]></title>
    <url>%2F2018%2F05%2F20%2F7-Hacks-for-ES6-Developers%2F</url>
    <content type="text"><![CDATA[1. 交换变量使用数组解构来交换变量的值1234let a = &apos;world&apos;, b = &apos;hello&apos;;[a, b] = [b, a];console.log(a); // helloconsole.log(b); // world 2. Async/Await和解构将数组解构和async/await以及promise结合可以使复杂的数据流变得简单1234const [user, account] = await Promise.all([ fetch(&apos;/user&apos;), fetch(&apos;/account&apos;)]); 3. Debuggingconsole.log更酷的使用方法：12345678const a = 5, b = 6, c = 7;console.log(&#123;a, b, c&#125;);// 输出//&#123;// a: 5,// b: 6,// c: 7//&#125; 4. 一行解决对于某些数组操作，可以使用更为简洁的语法1234567//找出最大值const max = (arr) =&gt; Math.max(...arr);max([123, 321, 23]); //输出 321//数组求和const sum = (arr) =&gt; arr.reduce((a, b) =&gt; (a + b), 0);sum([1, 2, 3, 4]); //输出 10 5. 数组合并扩展操作符可以用来代替concat：123456789101112const one = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];const two = [&apos;d&apos;, &apos;e&apos;, &apos;f&apos;];const three = [&apos;g&apos;, &apos;h&apos;, &apos;i&apos;];//常规方法1const result = one.concat(two, three);//常规方法2const result = [].concat(one, two, three);//新方法const result = [...one, ...two, ...three]; 6. 克隆12const obj = &#123; ...oldObj &#125;;const arr = [ ...oldArr ]; 注：以上方法创建的是一个浅克隆 7. 命名参数通过使用解构操作符让函数更易读：123456789101112const getStuffNotBad = (id, force, verbose) =&gt; &#123; ...&#125;const getStuffAwesome = (&#123; id, name, force, verbose &#125; =&gt; &#123; ...&#125;)//这种方法让人一时不知道这个几个参数表示的是什么getStuffNotBad(150, true, true);//参数意思一目了然getStuffAwesome(&#123; id: 150, force: true, verbose: true &#125;); 注： 本文版权归原作者所有，仅用于学习与交流； 如需转载译文，烦请按下方注明出处信息，谢谢！原文： 7 Hacks for ES6 Developers作者： Tal Bereznitskey译者：smallbone译文地址：https://medium.com/dailyjs/7-hacks-for-es6-developers-4e24ff425d0b 阅读原文]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何解决WebSocket的兼容性]]></title>
    <url>%2F2018%2F05%2F06%2F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3WebSocket%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[我们知道WebSocket是一种在服务器与客户端双向通讯的技术，使用原生的WebSocket可以最小化 服务器资源的使用并且为两者提供了一种统一的通信方式。随着HTML5的普及，现代浏览器（IE10+）基本上都已经原生支持WebSocket了，下面是支持WebSocket协议的浏览器： Internet Explorer 10 Firefox 6 Chrome 14 Safari 6.0 Opera 12.1 iOS Safari 6.0 Chrome for Android 27.0但是对于旧的浏览器该如何实现WebSocket的功能呢？下面就介绍一下几种常见的解决方案：1. SockJSSockJS是一个JavaScript库，它为浏览器提供了一个类似WebSocket的对象。首先，它会优先使用原生的WebSocket；如果不支持，则使用streaming；如果streaming也不支持，则使用轮询（polling）。下面是支持的浏览器概览： 既然模拟WebSocket双向通信，那么使用SockJS时，也要配合使用相应的服务器端的库，下面可以使用的服务器端库： SockJS-node SockJS-erlang SockJS-tornado SockJS-twisted SockJS-ruby SockJS-netty SockJS-gevent (SockJS-gevent fork) SockJS-go客户端的使用首先加载SockJS库1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js&quot;&gt;&lt;/script&gt; 库加载完后， 就可与SockJS服务器建立连接了1234567891011121314var sock = new SockJS(&apos;https://mydomain.com/my_prefix&apos;); sock.onopen = function() &#123; console.log(&apos;open&apos;); sock.send(&apos;test&apos;); &#125;; sock.onmessage = function(e) &#123; console.log(&apos;message&apos;, e.data); sock.close(); &#125;; sock.onclose = function() &#123; console.log(&apos;close&apos;); &#125;; 服务器端的使用(NodeJS)首先，安装sockjs-node:1npm install sockjs 接着就可以通过监听事件来与客户端进行类似WebSocket的通信了1234567891011121314var http = require(&apos;http&apos;);var sockjs = require(&apos;sockjs&apos;);var echo = sockjs.createServer(&#123; sockjs_url: &apos;http://cdn.jsdelivr.net/sockjs/1.0.1/sockjs.min.js&apos; &#125;);echo.on(&apos;connection&apos;, function(conn) &#123; conn.on(&apos;data&apos;, function(message) &#123; conn.write(message); &#125;); conn.on(&apos;close&apos;, function() &#123;&#125;);&#125;);var server = http.createServer();echo.installHandlers(server, &#123;prefix:&apos;/echo&apos;&#125;);server.listen(9999, &apos;0.0.0.0&apos;); 2. Socket.IOSocket.IO能够启用基于事件的双向通信，使用它同样也需要搭建相应的服务端；首先它也会首选WebSocket，如果不支持则会使用下面的替代方案： Adobe Flash Socket（缺点：需要在服务器上打开一个额外的端口，默认为10843） Ajax long polling Ajax multipart streaming Forever iframe JSONP polling浏览器兼容性 客户端1234567891011//加载Socket.IO库&lt;script src=&quot;http://localhost:8181/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var socket = io.connect(&apos;http://localhost:8181&apos;); console.log(&apos;a user connected&apos;); socket.emit(&apos;my other event&apos;, &#123; my: &apos;data&apos; &#125;); socket.on(&apos;disconnect&apos;, function()&#123; console.log(&apos;user disconnected&apos;); &#125;); &#125;);&lt;/script&gt; 服务端安装socket.io1npm install socket.io --save 配置服务器12345678var server = require(&apos;http&apos;).createServer();var io = require(&apos;socket.io&apos;)(server);io.on(&apos;connection&apos;, function(socket)&#123; socket.emit(&apos;news&apos;, &#123; hello: &apos;world&apos; &#125;); socket.on(&apos;event&apos;, function(data)&#123;&#125;); socket.on(&apos;disconnect&apos;, function()&#123;&#125;);&#125;);server.listen(3000);]]></content>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用File APIs来读取文件]]></title>
    <url>%2F2018%2F04%2F26%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8File-APIs%E6%9D%A5%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[兼容性检查12345if (window.File &amp;&amp; window.FileReader &amp;&amp; window.FileList &amp;&amp; window.Blob) &#123; //支持File APIs&#125; else &#123; //不支持File APIs&#125; FileReader()FileReader对象让web应用程序可以异步地读取存储在用户电脑上的文件(或者原始数据缓冲区)的内容。在JavaScript中，FileReaderd对象通过传入两种相应的对象(File和Blob)来进行数据的读取，而且这个方法在Web Workers中也能使用。 FileReader 包括四个异步读取文件的选项： FileReader.readAsBinaryString(Blob|File) - 返回值的result 属性将包含二进制字符串形式的file/blob 数据。每个字节均由一个 [0..255] 范围内的整数表示。 FileReader.readAsText(Blob|File, opt_encoding) - 返回值的result 属性将包含文本字符串形式的 file/blob 数据。该字符串在默认情况下采用“UTF-8”编码。使用可选编码参数可指定其他格式。 FileReader.readAsDataURL(Blob|File) - 返回值的result 属性将包含编码为数据网址的 file/blob 数据。 FileReader.readAsArrayBuffer(Blob|File) - 返回值的result 属性将包含 ArrayBuffer 对象形式的 file/blob 数据。 FileReader 对象调用其中某一种读取方法后，可使用 onloadstart、onprogress、onload、onabort、onerror 和 onloadend 跟踪其进度。 读取文件并显示进度下面的示例从用户选择的内容中过滤掉了图片，对文件调用 reader.readAsDataURL()，并通过将“src”属性设为数据网址来呈现缩略图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;style&gt; .thumb &#123; height: 75px; border: 1px solid #000; margin: 10px 5px 0 0; &#125; #list &#123; border: 1px solid lightgrey; padding: 15px; text-align: center; &#125; #progress_bar &#123; margin: 10px 0; padding: 3px; border: 1px solid #000; font-size: 14px; clear: both; opacity: 0; -moz-transition: opacity 1s linear; -o-transition: opacity 1s linear; -webkit-transition: opacity 1s linear; &#125; #progress_bar.loading &#123; opacity: 1.0; &#125; #progress_bar .percent &#123; background-color: #99ccff; height: auto; width: 0; &#125;&lt;/style&gt;&lt;body&gt; &lt;input type=&quot;file&quot; name=&quot;files[]&quot; id=&quot;files&quot; multiple /&gt; &lt;div id=&quot;list&quot;&gt;&lt;/div&gt; &lt;button onclick=&quot;abortRead();&quot;&gt;Cancel read&lt;/button&gt; &lt;script&gt; let reader; let progress; let progress_bar; function abortRead() &#123; reader.abort(); &#125; function errorHandler(evt) &#123; let error = evt.target.error; switch (error.code) &#123; case error.NOT_FOUND_ERR: alert(&apos;没有找到文件&apos;); break; case error.NOT_READABLE_ERR: alert(&apos;无法读取文件&apos;); break; case error.ABORT_ERR: break; default: alert(&apos;文件读取错误&apos;); &#125; &#125; function updateProgress(evt) &#123; if (evt.lengthComputable) &#123; let percentLoaded = Math.round((evt.loaded / evt.total) * 100); if (percentLoaded &lt; 100) &#123; progress.style.width = percentLoaded + &apos;%&apos;; progress.textContent = percentLoaded + &apos;%&apos;; &#125; &#125; &#125; function handleFileSelect(evt) &#123; let files = evt.target.files; //创建进度条 progress_bar = document.createElement(&apos;div&apos;); progress_bar.id = &apos;progress_bar&apos;; progress = document.createElement(&apos;div&apos;); progress.className = &apos;percent&apos;; progress.style.width = &apos;0%&apos;; progress.textContent = &apos;0%&apos;; progress_bar.appendChild(progress); document.getElementById(&apos;list&apos;).appendChild(progress_bar); for (let i = 0; i &lt; files.length; i++) &#123; reader = new FileReader(); if (!files[i].type.match(&apos;image.*&apos;)) &#123; alert(&apos;选择的文件不是图片&apos;); abortRead(); return; &#125; reader.onerror = errorHandler; reader.onprogress = updateProgress; reader.onabort = (e) =&gt; &#123; alert(&apos;文件读取已取消&apos;); &#125;; reader.onloadstart = (e) =&gt; &#123; progress_bar.className = &apos;loading&apos;; &#125;; reader.onload = (e) =&gt; &#123; let span = document.createElement(&apos;span&apos;); span.innerHTML = [&apos;&lt;img class=&quot;thumb&quot; src=&quot;&apos;, e.target.result, &apos;&quot; title=&quot;&apos;, files[i].name, &apos;&quot;/&gt;&apos;].join(&apos;&apos;); document.getElementById(&apos;list&apos;).insertBefore(span, progress_bar); progress.style.width = &apos;100%&apos;; progress.textContent = &apos;100%&apos;; &#125;; reader.readAsDataURL(files[i]); &#125; &#125; document.getElementById(&apos;files&apos;).addEventListener(&apos;change&apos;, handleFileSelect, false); &lt;/script&gt;&lt;/body&gt; See the Pen FileReader Demo by Lu (@smallbone) on CodePen. FileList API字面上可以理解为多个File对象组合成的数组，但是只有length属性和item(index)方法，访问其中的File对象既可以使用files.item(index)，也可以使用files[index]的方法。 File APIFile对象是一种特定类型的Blob。FileReader, URL.createObjectURL(), createImageBitmap(), 以及XMLHttpRequest.send() 都接受Blobs和Files。 File对象包含的信息12345678&#123; lastModified: 1428005315000, lastModifiedDate: Thu Apr 02 2015 15:08:35 GMT-0500 (CDT), name: &quot;profile.pdf&quot;, size: 135568, type: &quot;application/pdf&quot;, webkitRelativePath: &quot;&quot;&#125; 需要注意的是，type是根据文件扩展名来判断的，所以并不是很可靠。根据上面File对象的信息其实就可以实现一些常用的功能了，比如限制文件上传的大小，初步的限制文件上传的类型(当然也可以通过input元素的accept属性来实现，但是最终的类型验证还是需要在服务器端实现)。 File对象一般通过以下途径返回的FileList对象获取： &lt;input type=&quot;file&quot;&gt;的元素 拖拽操作的DataTransfer对象 通过在一个HTMLCanvasElement上调用mozGetAsFile() API 通过input来选择文件1234567/* 假设input元素为&lt;input type=&quot;file&quot; id=&quot;upload&quot; multiple&gt; *///multiple表示一次支持多个文件上传let uploadInput = document.getElementById(&apos;upload&apos;);uploadInput.addEventListener(&apos;change&apos;, ()=&gt;&#123; let fileList = uploadInput.files; console.log(fileList);&#125;); 由于FileList对象并没有forEach()方法，所以一般需要通过for循环来遍历其中的每个File对象：123for (var i = 0; fileCount = fileList.length; i &lt; fileCount; i++) &#123; console.log(fileList[i]);&#125; 但是我们也可以通过其他方式来使用forEach()方法：123456789//1.call方法[].forEach.call(fileList, (file, i, fileList)=&gt;&#123; ...&#125;);//2.ES6方法Array.from(uploadInput).forEach((i)=&gt;&#123; ...&#125;); 通过拖拽(drag&amp;drop)选择文件拖拽事件： drag(开始拖动，持续事件) dragend(释放鼠标或者按下ESC，结束拖动) dragenter(进入有效的拖拽区域时) dragexit(当一个元素不再是拖动操作的直接选择目标时) dragleave(离开有效的拖拽区域时) dragover(悬停在有效的拖拽区域内时，持续事件) dragstart(开始拖动) drop(目标放置到有效的拖拽区域时) 其中需要注意两点： 如果dragover事件不阻止默认事件，drop事件就不会被触发。 dragexit和dragleave在不同浏览器中的触发存在差异，dragexit在Chrome浏览器中就永远不会被触发。 12345678910111213141516171819202122232425262728//拖拽和显示区域&lt;div id=&quot;drop_zone&quot;&gt;Drop files here&lt;/div&gt;&lt;output id=&quot;list&quot;&gt;&lt;/output&gt;&lt;script&gt; function handleFileSelect(evt) &#123; evt.stopPropagation(); evt.preventDefault(); //注意这里不再是target.files let files = evt.dataTransfer.files; let output = []; [].forEach.call(files, (file)=&gt;&#123; output.push(&apos;&lt;li&gt;&lt;strong&gt;&apos;, file.name, &apos;&lt;/strong&gt; (&apos;, file.type || &apos;n/a&apos;, &apos;) - &apos;, (file.size/1024).toFixed(3), &apos; Kb, last modified date: &apos;, file.lastModifiedDate.toLocaleDateString(), &apos;&lt;/li&gt;&apos;); &#125;); document.getElementById(&apos;list&apos;).innerHTML = &apos;&lt;ul&gt;&apos; + output.join(&apos;&apos;) + &apos;&lt;/ul&gt;&apos;; &#125; function handleDragOver(evt) &#123; evt.stopPropagation(); evt.preventDefault(); evt.dataTransfer.dropEffect = &apos;copy&apos;; &#125; let dropZone = document.getElementById(&apos;drop_zone&apos;); dropZone.addEventListener(&apos;dragover&apos;, handleDragOver, false); dropZone.addEventListener(&apos;drop&apos;, handleFileSelect, false);&lt;/script&gt;]]></content>
      <tags>
        <tag>File APIs</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSocket简介]]></title>
    <url>%2F2018%2F04%2F21%2FWebSocket%2F</url>
    <content type="text"><![CDATA[WebSocket 是一种基于TCP的提供全双工/双向通信的通信协议，因为它原生支持跨域，且安全性较高，而且上手容易，是很好的跨域解决方案，甚至可以很容易的搭建一个聊天室。 使用方法客户端12//WebSocket接收两个参数，一个是URL(必须的)，一个是所使用的子协议（可选），可以是字符串也可以是数组，没有指定则为空字符。http使用ws，https使用wssvar ws = new WebSocket(&apos;ws://hostname:port&apos;) 服务器(NodeJS)123//create WebSocket Servervar WebSocketServer = require(&apos;ws&apos;).Server;var wss = new WebSocketServer(&#123;port: 8181&#125;); WebSocket事件 open 123ws.onopen = function(e) &#123; ...&#125; message 123ws.onmessage = function(e) &#123; ...&#125; error 123ws.onerror = function(e) &#123; ...&#125; close 123ws.onclose = function(e) &#123; ...&#125; WebSocket方法 send()可以传输两种类型的之：string和binary；因为WebSocket是事件驱动的协议，所以必须确保连接已经打开并且已经准备好接收信息了。 12345678910111213var ws = new WebSocket(&apos;ws://localhost:8181&apos;);ws.onopen = function(e) &#123; ws.send(JSON.stringigy(stock_request));&#125;//orfunction processEvent(e) &#123; if(ws.readState === WebSocket.OPEN) &#123; //Socket open, send ws.send(e); &#125; else &#123; //Show an error, queue it for sending later, etc &#125;&#125; close() 123ws.close();//or pass a numeric code and human-readable stringws.close(100, &quot;Goodbye, World!&quot;); WebSocket close()方法状态码https://developer.mozilla.org/zh-CN/docs/Web/API/CloseEvent WebSocket 属性当open事件触发后，WebSocket对象会有几个属性可以被客户端应用读取。 readyState| 属性名| 值| 描述|| :——– | ——–:|:– || WebSocket.CONNECTING| 0 | 连接还未打开|| WebSocket.OPEN| 1 | 连接已打开并准备通信|| WebSocket.CLOSING | 2 | 正在关闭连接 || WebSocket.CLOSED | 3 | 连接已关闭 | bufferedAmount常用于发送二进制数据，确保在连接关闭前所有数据已经发送或者在客户端执行某些限制 protocol服务器端所采用的子协议（在使用WebSocket构造器时指定的protocol参数，如果服务器没有采用则为空） 更多WebSocket详细信息参考MDN的WebSocket API]]></content>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS Grid]]></title>
    <url>%2F2018%2F01%2F07%2FCSS-Grid%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[(译)JavaScript的开销]]></title>
    <url>%2F2017%2F12%2F05%2FThe-cost-of-JavaScript%2F</url>
    <content type="text"><![CDATA[当我们建立严重依赖于JavaScript的网站时，我们不总是很容易看到我们发送的内容所付出的代价。在这篇文章中，如果你希望你的网站在移动设备上能够快速加载和互动，我将介绍为什么一些规则可以帮助你。 tl;dr：较少的代码=较少的解析/编译+较少的传输+较少的解压缩 网络当大多数开发人员考虑JavaScript的成本时，他们会考虑下载和执行成本。通过线路发送更多字节的JavaScript需要的时间越长，用户的连接也就越慢。 这可能是一个问题，即使在发达国家，因为用户有效的网络连接类型可能实际上并不是3G，4G或WiFi。你可能在咖啡店使用Wifi，但连接到的是2G的蜂窝热点。 您可以通过以下方式降低 JavaScript的网络传输成本： 只发送用户需要的代码。代码拆分这时候就有用武之地了。 压缩代码（ES515的 Uglify， ES2015的 babel- minify或uglify -es） 高度压缩（使用Brotli〜q11，Zopfli或gzip的）。Brotli的压缩比超过Gzip。它让CertSimple节省了17％的JS压缩字节大小，LinkedIn节省了 4％的加载时间。 删除未使用的代码。通过DevTools代码覆盖来确定。对于剥离的代码，可以查看tree shaking，闭包编译器的高级优化和微调库插件如lodash-babel-plugin插件或WebPack的ContextReplacementPlugin如Moment.js库。使用babel-preset-env和browserlist来避免现代浏览器中已经存在的转译功能。高级开发人员可能会发现仔细分析Webpack捆绑包有助于识别修剪不需要的依赖关系。 使用HTTP缓存以尽量减少网络跳转。确定脚本的最佳生命周期（max-age）和提供令牌验证（ETag）以避免传输没有变更的字节。Service Worker缓存可以使您的应用程序网络具有弹性，让您可以快速访问V8的代码缓存等功能。了解有关文件名哈希的长期缓存。 解析/编译一旦JS下载完毕，JavaScript最大的一个成本就是JS引擎解析/编译这段代码的时间。在Chrome DevTools中，解析和编译是“性能”面板中黄色“脚本”时间的一部分。 Bottom-Up/Call Tree允许查看确切的解析/编译时序：Chrome DevTools“性能”面板&gt;自下而上。通过启用V8的运行时调用统计，我们可以看到分析和编译阶段花费的时间 但是，为什么这会有问题呢？花费很长时间解析/编译代码会严重延迟用户与网站互动的时间。发送的JavaScript越多，在网站交互之前解析和编译的时间就越长。 同样多的字节，浏览器处理JavaScript要比同等大小的图像或Web字体开销更大。 - Tom Dale 与JavaScript相比，在处理等效大小的图片时（涉及到大量的图片仍然需要解码！），涉及到大量的开销，但是在一般的移动设备上，JS更有可能对页面的交互性产生负面影响。JavaScript和图像字节的开销有很大的不同。图像通常不会阻塞主线程，也不会阻止接口在解码和栅格化时进行的交互。然而JS由于解析，编译和执行的成本会延迟交互性。 当我们谈论解析和编译变慢的时候，上下文很重要 - 我们在这里谈论的普通手机。指的是大部分用户使用的CPU和GPU速度较慢的手机，无L2 / L3缓存，甚至可能内存很小。 网络功能和设备功能并不总是相匹配。使用光纤连接的用户不一定有最好的CPU来解析和执行发送到他们的设备的JavaScript。反过来也是如此。一个糟糕的网络连接，但却有一个快速的CPU。 - Kristofer Baxter，LinkedIn 在JavaScript启动性能中，我注意到在低端和高端硬件上解析大约1MB已经被解压的（简单）JavaScript的开销。在市场上最快的手机和普通手机之间解析/编译代码的时间有2-5倍的差异。在不同类别的桌面和移动设备上解析一个1MB的JavaScript包（约有250KB 被gzip压缩了）的解析时间。在查看解析的开销时，解压后的数据要考虑到大约有250KB 被gzip压缩的空间会被释放出来当解压缩大约1MB的代码的时候 那么现实世界的网站如何呢，如CNN.com在高端的iPhone 8上，解析/编译CNN的JS需要花费大约4秒，而普通手机（Moto G4）则只需要13秒。这可以显著影响用户与本网站完全交互的速度。苹果的A11仿生芯片和非常普通的Android硬件中的Snapdragon 617的解析时间性能比较。 这突出了普通硬件（如Moto G4）测试的重要性，而不仅仅是口袋里的手机。但是，使用环境很重要：优化您的用户拥有的设备和网络条件。 分析可以深入了解您的真实用户访问您的网站的移动设备类别。这可以提供机会来了解他们正在使用的真正的CPU / GPU的限制。 我们是否真的发送了太多的JavaScript？错误，这很有可能:) 使用HTTP Archive（最高大约50万个站点）来分析移动设备上JavaScript的状态，我们可以看到，50％的站点需要14秒才能获得交互。仅仅只是解析和编译JS，这些网站就花费长达4秒。 在获取和处理JS和其他资源所花费的时间中，因为感觉网页已经可以使用，用户可能会等待一段时间，这也许并不奇怪。但我们一定可以在这里做得更好。 从网页中删除不重要的JavaScript可以减少传输时间，CPU密集型解析和编译以及潜在的内存开销。这也有助于让您的网页更快地交互。 执行时间这不仅仅是解析和编译，而且可能会带来额外的开销。JavaScript执行（一次解析/编译运行代码）是在主线程上发生的操作之一。很长的执行时间也可以推出用户可以与网站互动的时间。 如果脚本执行时间超过50ms，则交互时间会被下载，编译和执行JS所花时间延迟了 - Alex Russell 为了解决这个问题，JavaScript受益于small chunks，以避免锁定主线程。探索是否可以减少执行过程中正在进行的工作量。 减少JavaScript发送开销的模式当你试图保持JavaScript的解析/编译和网络传输时间很慢时，有一些模式可以帮助像基于路由的分块(route-based chunking)或PRPL。 PRPL是一种通过代码分割和缓存来优化交互性的模式： 让我们看看它可以产生的影响。我们使用V8的运行时调用统计来分析流行移动网站和Progressive Web Apps的加载时间。正如我们所看到的，解析时间（以橙色显示）是许多这些站点花费时间的比较大的部分： Wego是一个使用PRPL的网站，它设法保持较低的路由解析时间，能够非常迅速地进行互动。上面的许多其他站点都采用代码分解和性能预算来降低JS的开销。 其他开销JavaScript可以通过其他方式影响页面性能： 内存。由于GC（垃圾收集），页面可能经常会出现卡顿或暂停。当浏览器回收内存时，JS执行被暂停，所以经常进行垃圾收集的浏览器可以比我们想要的更频繁地暂停执行。避免内存泄漏和频繁的gc暂停，以保持页面流畅。 在运行时，长时间运行的JavaScript可以阻止主线程导致无响应的页面。将工作分成更小的部分（使用requestAnimationFrame（）或有计划的使用requestIdleCallback（））可以最大限度地减少响应性问题。 渐进式引导许多网站将内容可视性作为交互性的代价来优化。为了在有大的JavaScript包时获得一个快速的首页，开发者有时会使用服务器端渲染;然后在JavaScript最终获取时将其“升级”以附加事件处理程序。 小心 - 这有它自己的开销。1）这通常会发送一个更大的 HTML响应，这会延迟交互性，2）这会把用户留在一个离奇的山谷中，其中有一半的实际功能是没有办法交互的，直到JavaScript运行完成。 渐进式引导可能是一个更好的方法。发送一个最小功能的页面（由当前路由所需的HTML / JS / CSS组成）。随着更多的资源到达，该应用程序可以延迟加载和解锁更多的功能。Paul Lewis的渐进式引导视觉 根据所看到的加载代码是圣杯。PRPL和渐进引导是可以帮助实现这一点的模式。 结论传输大小对低端网络至关重要。解析时间对于CPU受限的设备很重要。保持这两者的抵开销。 团队发现成功采用严格的性能预算来保持JavaScript传输和解析/编译时间较短。请参阅Alex Russell的“ 您可以承受吗？：真实世界的Web性能预算 ”，以获取关于移动预算的指导。考虑一下我们制作的架构决策可以为应用程序逻辑留下多少JS“空间”。 如果您正在构建针对移动设备的网站，请尽可能在代表性硬件上开发，保持较低的JavaScript分析/编译时间，并采用性能预算来确保您的团队能够关注其JavaScript成本。 注： 本文版权归原作者所有，仅用于学习与交流； 如需转载译文，烦请按下方注明出处信息，谢谢！原文： The Cost Of JavaScript作者： Addy Osmani译者：smallbone原文地址]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>性能</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了不起的NodeJS：MongoDB代码更正]]></title>
    <url>%2F2017%2F10%2F01%2Fsmashingnode-master-code%2F</url>
    <content type="text"><![CDATA[最近在学习NodeJS，在网上一番搜索资料后，很多人都建议读《了不起的NodeJS》，于是就开始开始啃起来了。在一边读一边敲代码的的过程中发现书中有些示例中的代码存在书写或者框架的更新导致运行出错，花了不少时间学习框架的更新和库的使用方法，才让代码运行正常。下面就是有关MongoDB代码更正： express实例创建书上的写法1var app = express.createServer(); 更新后的写法1var app = express(); 中间件书上的写法1234//源代码app.use(express.bodyParser());app.use(express.cookieParser());app.use(express.session(&#123;secret: &apos;my secret&apos;&#125;)); 由于新版的express中将原来自身的大部分中间件都移除了，所以需要额外安装并引用。123456789//更正后var session = require(&apos;express-session&apos;);var cookieParser = require(&apos;cookie-parser&apos;);var bodyParser = require(&apos;body-parser&apos;);app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: true &#125;));app.use(cookieParser());app.use(session(&#123;secret: &apos;my secret&apos;&#125;)); bodyParser.urlencoded中的extented设置选项是用来控制POST传递的值是放能被对象化，例如下面的jade模板中input信息1input(name=&quot;user[first]&quot;, type=&quot;text&quot;) { extended: true }: req.body 为 { user: { name: ‘123123’ } }{ extended: false }: req.body 为 { ‘user[name]’: ‘12313’ } Jade模板Jade模板已经更名为Pug，但是仍然可以使用jade。 doctype的变更： doctype 5 =&gt; doctype html 书中index模板中的block body下的代码应该缩进1234567891011//更正后extends layoutblock content if (authenticated) p Welcome back, #&#123;me.first&#125; a(href=&quot;/logout&quot;) Logout else p Welcome new visitor! ul li: a(href=&quot;/login&quot;) Login li: a(href=&quot;/signup&quot;) Signup mongodb新建collection12//源代码app.users = new mongodb.Collection(client, &apos;users&apos;); 这里 Collection 是 mongodb 的方法得用小写,另外在使用 mongodb 之前记得要先用 mongod 命令开启服务器12//更正后app.users = new mongodb.collection(client, &apos;users&apos;); mongodb insert 后的回调使用123456//源代码app.users.insert(req.body.user, function (err, doc) &#123;if (err) next(err);console.log(doc);res.redirect(&apos;/login/&apos; + doc[0].email);&#125;); doc 变成了一个对象，拥有 result 和 ops 两个属性,我们需要的数据在 ops 里面12345app.users.insert(req.body.user, function (err, doc) &#123;if (err) next(err);console.log(doc);res.redirect(&apos;/login/&apos; + doc.ops[0].email);&#125;); 204页忘记传 next 了…12345678//源代码app.post(&apos;/login&apos;, function (req, res) &#123;app.users.findOne(&#123;email: req.body.email, password: req.body.password&#125;, function (err, doc) &#123;if (err) return next(err);if (!doc) return res.send(&apos;&lt;p&gt;User not found &lt;/p&gt;&apos;);req.session.loggedIn = doc._id.toString();&#125;);&#125;); 12345678//更正后app.post(&apos;/login&apos;, function (req, res, next) &#123;app.users.findOne(&#123;email: req.body.email, password: req.body.password&#125;, function (err, doc) &#123;if (err) return next(err);if (!doc) return res.send(&apos;&lt;p&gt;User not found &lt;/p&gt;&apos;);req.session.loggedIn = doc._id.toString();&#125;);&#125;); mongodb的_id查询使用 mongodb 的 _id 进行查询,原文中的指代方法已经不能使用了。而 node 本身不提供生成 objectid 的方法这里需要依赖第三方工具12345//源代码app.users.findOne(&#123;_id: &#123;$oid: req.session.loggedIn&#125;&#125;, function (err, doc) &#123;if (err) return next(err);next();&#125;); 1234567//更正后var objectid = require(&apos;objectid&apos;);app.users.findOne(&#123;_id: objectid(req.session.loggedIn)&#125;, function (err, doc) &#123;if (err) return next(err);next();&#125;); jade中全局变量 locals 的使用1234567891011121314//源代码app.use(function (req, res, next) &#123;if (req.session.loggedIn) &#123;res.local(&apos;auth&apos;, true);app.users.findOne(&#123;_id: objectid(req.session.loggedIn)&#125;, function (err, doc) &#123;if (err) return next(err);res.local(&apos;me&apos;, doc);next();&#125;);&#125; else &#123;res.local(&apos;auth&apos;, false);next();&#125;&#125;); 这里 express 的定义方法更改了,另外使用 mongodb 查询的时候如果没有查找到并不会报错,而是在回调的 doc 设为 null。 1234567891011121314//更正后app.use(function (req, res, next) &#123;if (req.session.loggedIn) &#123;app.locals.auth = true;app.users.findOne(&#123;_id: objectid(req.session.loggedIn)&#125;, function (err, doc) &#123;if (err) return next(err);if (doc) app.locals.me = doc;next();&#125;);&#125; else &#123;app.locals.auth = false;next();&#125;&#125;);]]></content>
      <tags>
        <tag>Node</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的Sets简介]]></title>
    <url>%2F2017%2F07%2F16%2FSets-in-JavaScript%2F</url>
    <content type="text"><![CDATA[Sets 是ES6(ES2015)中一个新的对象类型，用来创建一系列唯一值的集合.集合中的值可以是简单的原始类型如字符串(strings)或整数(integers)，也可以是更复杂的对象类型如对象字面量或者数组 基本方法下面是基本的set及其方法(add, size, has, forEach, delete, clear)的简单示例： 12345678910111213141516171819202122232425let animals = new Set();animals.add('🐷');animals.add('🐼');animals.add('🐢');animals.add('🐿');console.log(animals.size); // 4animals.add('🐼');console.log(animals.size); // 4console.log(animals.has('🐷')); // trueanimals.delete('🐷');console.log(animals.has('🐷')); // falseanimals.forEach(animal =&gt; &#123; console.log(`Hey $&#123;animal&#125;!`);&#125;);// Hey 🐼!// Hey 🐢!// Hey 🐿!animals.clear();console.log(animals.size); // 0 初始化下面是另一个将数组作为初始值传进set的示例。需要主要的是初始化的数组是如何被解构的，但是随后添加的数组将以数组的形式存在： 123456789101112131415let myAnimals = new Set(['🐷', '🐢', '🐷', '🐷']);myAnimals.add(['🐨', '🐑']);myAnimals.add(&#123; name: 'Rud', type: '🐢' &#125;);console.log(myAnimals.size); // 4myAnimals.forEach(animal =&gt; &#123; console.log(animal);&#125;);// 🐷// 🐢// ["🐨", "🐑"]// Object &#123; name: "Rud", type: "🐢" &#125; 字符串也是一个有效的迭代，所以也可以被传入来初始化一个set： 1234console.log('Only unique characters will be in this set.'.length); // 43let sentence = new Set('Only unique characters will be in this set.');console.log(sentence.size); // 18 For…of遍历除了在一个set上可以使用forEach外，for…of循环也可以被用来遍历sets： 12345678910let moreAnimals = new Set(['🐺', '🐴', '🐕', '🐇']);for (let animal of moreAnimals) &#123; console.log(`Howdy $&#123; animal &#125;`);&#125;// Howdy 🐺// Howdy 🐴// Howdy 🐕// Howdy 🐇 Keys 和 ValuesSets也有keys和values方法，由于keys是values的别名，所以两个方法其实是完成一样的事情。使用两者中的任何一个方法都会返回一个新的可迭代的对象，该对象的值与添加到集合中的顺序相同。 123456789101112131415161718192021222324let partyItems = new Set(['🍕', '🍾', '🎊']);let items = partyItems.values();console.log(items.next());console.log(items.next());console.log(items.next());console.log(items.next().done);// Object &#123;// done: false,// value: "🍕"// &#125;// Object &#123;// done: false,// value: "🍾"// &#125;// Object &#123;// done: false,// value: "🎊"// &#125;// true 注： 本文版权归原作者所有，仅用于学习与交流； 如需转载译文，烦请按下方注明出处信息，谢谢！原文： Introduction to Sets in JavaScript作者： alligatorio译者：smallbone译文地址：https://alligator.io//js/sets-introduction/]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Sets</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex Basis与Width的区别]]></title>
    <url>%2F2017%2F07%2F08%2FWidth-FlexBasis%2F</url>
    <content type="text"><![CDATA[最近在学习Flex Box，其中的Flex Box属性中的Flex Basis是关于项目宽度属性设置的，这让许多初学Flex Box的人困惑它与CSS盒子模型Width属性的区别在哪？Google了一番，找到一篇解释写得很是不错的文章，尝试着翻译分享一下。原文地址：http://gedd.ski/post/the-difference-between-width-and-flex-basis/ Flex Items的应用准则content –&gt; width –&gt; flex-basis (limted by max|min-width)也就是说， 如果没有设置flex-basis属性，那么flex-basis的大小就是项目的width属性的大小 如果没有设置width属性，那么flex-basis的大小就是项目内容(content)的大小 下面通过给一个1000px的flex容器来添加一些flex items来说明一下Flex Items的应用准则：1234container &#123; display: flex; width: 1000px;&#125; 设置宽度(Width)添加四个200x200像素的items到flex容器中1234item &#123; width: 200px; height: 200px;&#125; 因为flex容器有足够多的空间，所以items可以很好的填充在容器内部：上面的示例就是当flex-basis没有被指定，默认值是flex-basis: auto，也就意味着items以宽度width(200px)为准。 设置一个Flex Basis值让我们看看当给这些已经设置固定宽度width的items设置一个flex-basis值会发生什么。1234item &#123; width: 30px; flex-basis: 250px;&#125; 就像你说看到的，当指定一个flex-basis值的时候，盒子的宽度属性被忽略了，所以我们就不需要指定盒子的宽度width属性了123item &#123; flex-basis: 250px;&#125; items完全填充了flex容器：因此items的宽度关键在用最终的flex-basis。最佳的方法是只使用flex-basis而不是width或height属性。特别是Safari 10之前的版本的浏览器有一个flexbox bug，在给items应用flex-shrink属性的时候，浏览器会使用height属性而不是flex-basis。 使用max-width来限制flex-basismin-width和max-width会限制flex-basis值。下面是给flex items设置max-width的结果：1234item &#123; flex-basis: 250px; max-width: 100px;&#125; 可以看到即使我们将flex-basis设置为250px，item的宽度还是被限制在了100px。所以在这个示例中最终的flex-basis是100px：接着试试min-width来看看最终的flex-basis有什么不同：1234item &#123; flex-basis: 100px; min-width: 250px;&#125; 可以看到最终item的宽度是250px而不是100px： Flex-basis到底是什么？现在我们知道了width属性只是一个当flex-basis没有被设置时的回退选项。min-width和max-width则是flex-basis的下限和上限。那么flex-basis到底是什么呢？ 也许你注意到了上面我们所有的示例在将flex items放入flex容器之前都直观地列出了flex items的大小。之所以这么做是因为这就是flex-basis的含义：flex items 在被放进一个flex容器之前的大小。也就是items理想或假设的大小。但是flex-basis不能保证其大小！一旦将items放入flex容器中，flex-basis的值就无法保证了。在上面的示例中，你可以看到flex items完美地填充了容器，那是因为容器的大小正好等于items最终的flex-basis之和。但是如果容器没有足够的空间来容纳或者有多余的空间呢？下面就分别讲解一下这两种情况： 当没有足够空间的时候比方说我们想要放更多的flex-basis：200px的items到我们的容器：在items被放进容器之前，每个item会占据200px，所有的items会占据1600px。但是容器只有1000px。当容器没有足够大的空间来存放所有的items的时候，flex items会按照压缩率(shrink rate)被压缩(shrink)其大小来填充容器,这个压缩率就是flex-shrink来设置的，默认情况下每个item的压缩率都是一样的： 当有额外的空间的时候通常我们会有额外的空间剩余当所有的items都添加进容器后：123item &#123; flex-basis: 100px;&#125; 我们可以控制flex items的增长来填充可用的空间，这也就是flex-grow属性的作用。默认值为0，意味着item不会增长。如果将每个item设置flex-grow： 1，那么所有 的item都会等比例的增长来填充剩余的空间：1234item &#123; flex-basis: 100px; flex-grow: 1;&#125; 增长和压缩是flexbox中很重要的特性，也让flexbox非常适合应用于响应式UI设计。Flexbox Zombies课程涵盖了flex-shrink和flex-grow更多详细的细节。 Width vs flex-basis希望现在你明白了width和flex-basis之间的区别，也知道了如何使用min-width和max-width来限制最终的flex-basis。以上这些设置同样适用于height属性，当你将flex-direction设置为column或者column-reverse的时候。如果你想掌握所有的flexbox属性，墙裂推荐免费的Flexbox Zombies课程，通过玩游戏来学习flexbox！]]></content>
      <tags>
        <tag>翻译</tag>
        <tag>CSS</tag>
        <tag>FlexBox</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
</search>