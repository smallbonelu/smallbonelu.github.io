<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BeautifulSoup4 find_all搜索包含指定文本内容的标签返回空list的问题]]></title>
    <url>%2F2018%2F08%2F30%2FBeautifulSoup4%E6%90%9C%E7%B4%A2%E5%8C%85%E5%90%AB%E6%8C%87%E5%AE%9A%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%E7%9A%84%E6%A0%87%E7%AD%BE%E8%BF%94%E5%9B%9E%E7%A9%BAlist%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近帮助公司其他团队用python写了一个爬虫，遇到了不少问题，其中就有一个问题是使用BeautifulSoup4的find_all搜索包含指定文本内容时返回的是空的list，查看了官方文档也上google搜索了一些类似的问题，发现是因为在使用bs4的find_all结合正则表达式查找指定文本的时候，搜索的是bs4返回元素中string属性中的信息，而不是text属性。并且如果某个元素中如果还包含除了文本之外的子元素，string属性返回会是None，而不是像text属性中那样的文本信息。 如果HTML中的内容结构像下面这样:1234&lt;td&gt;some text&lt;/td&gt; &lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;more text&lt;/p&gt;&lt;/td&gt;&lt;td&gt;even &lt;p&gt;more text&lt;/p&gt;&lt;/td&gt; td 上的.string属性将会返回下面的内容：1、some text2、None3、more text4、None .text 属性将会返回下面的内容：1、some text2、3、more text4、even more text 如果想要了解.find和.string之间的差异可以查看Python BeautifulSoup 中.text与.string的区别 解决办法是使用lambda函数12&gt;&gt;&gt; soup.find_all(lambda e: e.name == &apos;td&apos; and &apos;Black&apos; in e.text)[&lt;td id=&quot;rp10&quot; valign=&quot;top&quot;&gt;Black or African American alone, percent, 2013 (a) &lt;!-- RHI225213 --&gt; &lt;/td&gt;, &lt;td id=&quot;re6&quot; valign=&quot;top&quot;&gt;Black-owned firms, percent, 2007 &lt;!-- SBO315207 --&gt; &lt;/td&gt;]]]></content>
      <tags>
        <tag>BeautifulSoup4</tag>
        <tag>python爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何解决公网无法访问阿里云ECS搭建的MongoDB服务]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%85%AC%E7%BD%91%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E9%98%BF%E9%87%8C%E4%BA%91ECS%E6%90%AD%E5%BB%BA%E7%9A%84MongoDB%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[最近为了学习后端购买了一台阿里云ECS云服务器（专用网络）环境如下：OS：Ubuntu16.04，MongoDB：v4.0.1 尝试着安装了MongoDB并进行了相应的配置，搜索了一些资料发现关键在于三点： MongoDB的bindIp配置： MongoDB默认的配置文件中，bindIp选项默认是localhost，也就是说默认只有安装了MongoDB的主机自己能够访问。所以如果需要外网的主机能够访问MongoDB服务，首先需要更改bindIp选项，将其设置为指定的IP地址(x.x.x.x, …)者绑定所有的IP地址(0.0.0.0 )。MongoDB 3.6之后的版本新增了bindIpAll选项，true代表绑定所有IP地址。 配置文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142# mongod.conf# for documentation of all options, see:# http://docs.mongodb.org/manual/reference/configuration-options/# Where and how to store data.storage: dbPath: /var/lib/mongodb journal: enabled: true# engine:# mmapv1:# wiredTiger:# where to write logging data.systemLog: destination: file logAppend: true path: /var/log/mongodb/mongod.log# network interfacesnet: port: 27017 bindIpAll: true # how the process runsprocessManagement: timeZoneInfo: /usr/share/zoneinfo#security:#operationProfiling:#replication:#sharding:## Enterprise-Only Options:#auditLog:#snmp: Linux防火墙iptables的配置： 在bash中输入sudo iptables -A INPUT -p tcp --destination-port 27017 -m state --state NEW,ESTABLISHED -j ACCEPTsudo iptables -A OUTPUT -p tcp --source-port 27017 -m state --state ESTABLISHED -j ACCEPT 开放MongoDB的端口。 接着输入iptables-save和 iptables-restore保存iptables的配置信息以免主机重启后需要重新配置。 ECS主机的安全组规则配置： 经过以上的配置后，就能够远程连接阿里云ECS上搭建的MongoDB服务了。]]></content>
      <tags>
        <tag>MongoDB</tag>
        <tag>Ubuntu</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(译)7个ES6编程小技巧]]></title>
    <url>%2F2018%2F05%2F20%2F7-Hacks-for-ES6-Developers%2F</url>
    <content type="text"><![CDATA[1. 交换变量使用数组解构来交换变量的值1234let a = &apos;world&apos;, b = &apos;hello&apos;;[a, b] = [b, a];console.log(a); // helloconsole.log(b); // world 2. Async/Await和解构将数组解构和async/await以及promise结合可以使复杂的数据流变得简单1234const [user, account] = await Promise.all([ fetch(&apos;/user&apos;), fetch(&apos;/account&apos;)]); 3. Debuggingconsole.log更酷的使用方法：12345678const a = 5, b = 6, c = 7;console.log(&#123;a, b, c&#125;);// 输出//&#123;// a: 5,// b: 6,// c: 7//&#125; 4. 一行解决对于某些数组操作，可以使用更为简洁的语法1234567//找出最大值const max = (arr) =&gt; Math.max(...arr);max([123, 321, 23]); //输出 321//数组求和const sum = (arr) =&gt; arr.reduce((a, b) =&gt; (a + b), 0);sum([1, 2, 3, 4]); //输出 10 5. 数组合并扩展操作符可以用来代替concat：123456789101112const one = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];const two = [&apos;d&apos;, &apos;e&apos;, &apos;f&apos;];const three = [&apos;g&apos;, &apos;h&apos;, &apos;i&apos;];//常规方法1const result = one.concat(two, three);//常规方法2const result = [].concat(one, two, three);//新方法const result = [...one, ...two, ...three]; 6. 克隆12const obj = &#123; ...oldObj &#125;;const arr = [ ...oldArr ]; 注：以上方法创建的是一个浅克隆 7. 命名参数通过使用解构操作符让函数更易读：123456789101112const getStuffNotBad = (id, force, verbose) =&gt; &#123; ...&#125;const getStuffAwesome = (&#123; id, name, force, verbose &#125; =&gt; &#123; ...&#125;)//这种方法让人一时不知道这个几个参数表示的是什么getStuffNotBad(150, true, true);//参数意思一目了然getStuffAwesome(&#123; id: 150, force: true, verbose: true &#125;); 注： 本文版权归原作者所有，仅用于学习与交流； 如需转载译文，烦请按下方注明出处信息，谢谢！原文： 7 Hacks for ES6 Developers作者： Tal Bereznitskey译者：smallbone译文地址：https://medium.com/dailyjs/7-hacks-for-es6-developers-4e24ff425d0b 阅读原文]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何解决WebSocket的兼容性]]></title>
    <url>%2F2018%2F05%2F06%2F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3WebSocket%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[我们知道WebSocket是一种在服务器与客户端双向通讯的技术，使用原生的WebSocket可以最小化 服务器资源的使用并且为两者提供了一种统一的通信方式。随着HTML5的普及，现代浏览器（IE10+）基本上都已经原生支持WebSocket了，下面是支持WebSocket协议的浏览器： Internet Explorer 10 Firefox 6 Chrome 14 Safari 6.0 Opera 12.1 iOS Safari 6.0 Chrome for Android 27.0但是对于旧的浏览器该如何实现WebSocket的功能呢？下面就介绍一下几种常见的解决方案：1. SockJSSockJS是一个JavaScript库，它为浏览器提供了一个类似WebSocket的对象。首先，它会优先使用原生的WebSocket；如果不支持，则使用streaming；如果streaming也不支持，则使用轮询（polling）。下面是支持的浏览器概览： 既然模拟WebSocket双向通信，那么使用SockJS时，也要配合使用相应的服务器端的库，下面可以使用的服务器端库： SockJS-node SockJS-erlang SockJS-tornado SockJS-twisted SockJS-ruby SockJS-netty SockJS-gevent (SockJS-gevent fork) SockJS-go客户端的使用首先加载SockJS库1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js&quot;&gt;&lt;/script&gt; 库加载完后， 就可与SockJS服务器建立连接了1234567891011121314var sock = new SockJS(&apos;https://mydomain.com/my_prefix&apos;); sock.onopen = function() &#123; console.log(&apos;open&apos;); sock.send(&apos;test&apos;); &#125;; sock.onmessage = function(e) &#123; console.log(&apos;message&apos;, e.data); sock.close(); &#125;; sock.onclose = function() &#123; console.log(&apos;close&apos;); &#125;; 服务器端的使用(NodeJS)首先，安装sockjs-node:1npm install sockjs 接着就可以通过监听事件来与客户端进行类似WebSocket的通信了1234567891011121314var http = require(&apos;http&apos;);var sockjs = require(&apos;sockjs&apos;);var echo = sockjs.createServer(&#123; sockjs_url: &apos;http://cdn.jsdelivr.net/sockjs/1.0.1/sockjs.min.js&apos; &#125;);echo.on(&apos;connection&apos;, function(conn) &#123; conn.on(&apos;data&apos;, function(message) &#123; conn.write(message); &#125;); conn.on(&apos;close&apos;, function() &#123;&#125;);&#125;);var server = http.createServer();echo.installHandlers(server, &#123;prefix:&apos;/echo&apos;&#125;);server.listen(9999, &apos;0.0.0.0&apos;); 2. Socket.IOSocket.IO能够启用基于事件的双向通信，使用它同样也需要搭建相应的服务端；首先它也会首选WebSocket，如果不支持则会使用下面的替代方案： Adobe Flash Socket（缺点：需要在服务器上打开一个额外的端口，默认为10843） Ajax long polling Ajax multipart streaming Forever iframe JSONP polling浏览器兼容性 客户端1234567891011//加载Socket.IO库&lt;script src=&quot;http://localhost:8181/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var socket = io.connect(&apos;http://localhost:8181&apos;); console.log(&apos;a user connected&apos;); socket.emit(&apos;my other event&apos;, &#123; my: &apos;data&apos; &#125;); socket.on(&apos;disconnect&apos;, function()&#123; console.log(&apos;user disconnected&apos;); &#125;); &#125;);&lt;/script&gt; 服务端安装socket.io1npm install socket.io --save 配置服务器12345678var server = require(&apos;http&apos;).createServer();var io = require(&apos;socket.io&apos;)(server);io.on(&apos;connection&apos;, function(socket)&#123; socket.emit(&apos;news&apos;, &#123; hello: &apos;world&apos; &#125;); socket.on(&apos;event&apos;, function(data)&#123;&#125;); socket.on(&apos;disconnect&apos;, function()&#123;&#125;);&#125;);server.listen(3000);]]></content>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用File APIs来读取文件]]></title>
    <url>%2F2018%2F04%2F26%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8File-APIs%E6%9D%A5%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[兼容性检查12345if (window.File &amp;&amp; window.FileReader &amp;&amp; window.FileList &amp;&amp; window.Blob) &#123; //支持File APIs&#125; else &#123; //不支持File APIs&#125; FileReader()FileReader对象让web应用程序可以异步地读取存储在用户电脑上的文件(或者原始数据缓冲区)的内容。在JavaScript中，FileReaderd对象通过传入两种相应的对象(File和Blob)来进行数据的读取，而且这个方法在Web Workers中也能使用。 FileReader 包括四个异步读取文件的选项： FileReader.readAsBinaryString(Blob|File) - 返回值的result 属性将包含二进制字符串形式的file/blob 数据。每个字节均由一个 [0..255] 范围内的整数表示。 FileReader.readAsText(Blob|File, opt_encoding) - 返回值的result 属性将包含文本字符串形式的 file/blob 数据。该字符串在默认情况下采用“UTF-8”编码。使用可选编码参数可指定其他格式。 FileReader.readAsDataURL(Blob|File) - 返回值的result 属性将包含编码为数据网址的 file/blob 数据。 FileReader.readAsArrayBuffer(Blob|File) - 返回值的result 属性将包含 ArrayBuffer 对象形式的 file/blob 数据。 FileReader 对象调用其中某一种读取方法后，可使用 onloadstart、onprogress、onload、onabort、onerror 和 onloadend 跟踪其进度。 读取文件并显示进度下面的示例从用户选择的内容中过滤掉了图片，对文件调用 reader.readAsDataURL()，并通过将“src”属性设为数据网址来呈现缩略图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;style&gt; .thumb &#123; height: 75px; border: 1px solid #000; margin: 10px 5px 0 0; &#125; #list &#123; border: 1px solid lightgrey; padding: 15px; text-align: center; &#125; #progress_bar &#123; margin: 10px 0; padding: 3px; border: 1px solid #000; font-size: 14px; clear: both; opacity: 0; -moz-transition: opacity 1s linear; -o-transition: opacity 1s linear; -webkit-transition: opacity 1s linear; &#125; #progress_bar.loading &#123; opacity: 1.0; &#125; #progress_bar .percent &#123; background-color: #99ccff; height: auto; width: 0; &#125;&lt;/style&gt;&lt;body&gt; &lt;input type=&quot;file&quot; name=&quot;files[]&quot; id=&quot;files&quot; multiple /&gt; &lt;div id=&quot;list&quot;&gt;&lt;/div&gt; &lt;button onclick=&quot;abortRead();&quot;&gt;Cancel read&lt;/button&gt; &lt;script&gt; let reader; let progress; let progress_bar; function abortRead() &#123; reader.abort(); &#125; function errorHandler(evt) &#123; let error = evt.target.error; switch (error.code) &#123; case error.NOT_FOUND_ERR: alert(&apos;没有找到文件&apos;); break; case error.NOT_READABLE_ERR: alert(&apos;无法读取文件&apos;); break; case error.ABORT_ERR: break; default: alert(&apos;文件读取错误&apos;); &#125; &#125; function updateProgress(evt) &#123; if (evt.lengthComputable) &#123; let percentLoaded = Math.round((evt.loaded / evt.total) * 100); if (percentLoaded &lt; 100) &#123; progress.style.width = percentLoaded + &apos;%&apos;; progress.textContent = percentLoaded + &apos;%&apos;; &#125; &#125; &#125; function handleFileSelect(evt) &#123; let files = evt.target.files; //创建进度条 progress_bar = document.createElement(&apos;div&apos;); progress_bar.id = &apos;progress_bar&apos;; progress = document.createElement(&apos;div&apos;); progress.className = &apos;percent&apos;; progress.style.width = &apos;0%&apos;; progress.textContent = &apos;0%&apos;; progress_bar.appendChild(progress); document.getElementById(&apos;list&apos;).appendChild(progress_bar); for (let i = 0; i &lt; files.length; i++) &#123; reader = new FileReader(); if (!files[i].type.match(&apos;image.*&apos;)) &#123; alert(&apos;选择的文件不是图片&apos;); abortRead(); return; &#125; reader.onerror = errorHandler; reader.onprogress = updateProgress; reader.onabort = (e) =&gt; &#123; alert(&apos;文件读取已取消&apos;); &#125;; reader.onloadstart = (e) =&gt; &#123; progress_bar.className = &apos;loading&apos;; &#125;; reader.onload = (e) =&gt; &#123; let span = document.createElement(&apos;span&apos;); span.innerHTML = [&apos;&lt;img class=&quot;thumb&quot; src=&quot;&apos;, e.target.result, &apos;&quot; title=&quot;&apos;, files[i].name, &apos;&quot;/&gt;&apos;].join(&apos;&apos;); document.getElementById(&apos;list&apos;).insertBefore(span, progress_bar); progress.style.width = &apos;100%&apos;; progress.textContent = &apos;100%&apos;; &#125;; reader.readAsDataURL(files[i]); &#125; &#125; document.getElementById(&apos;files&apos;).addEventListener(&apos;change&apos;, handleFileSelect, false); &lt;/script&gt;&lt;/body&gt; See the Pen FileReader Demo by Lu (@smallbone) on CodePen. FileList API字面上可以理解为多个File对象组合成的数组，但是只有length属性和item(index)方法，访问其中的File对象既可以使用files.item(index)，也可以使用files[index]的方法。 File APIFile对象是一种特定类型的Blob。FileReader, URL.createObjectURL(), createImageBitmap(), 以及XMLHttpRequest.send() 都接受Blobs和Files。 File对象包含的信息12345678&#123; lastModified: 1428005315000, lastModifiedDate: Thu Apr 02 2015 15:08:35 GMT-0500 (CDT), name: &quot;profile.pdf&quot;, size: 135568, type: &quot;application/pdf&quot;, webkitRelativePath: &quot;&quot;&#125; 需要注意的是，type是根据文件扩展名来判断的，所以并不是很可靠。根据上面File对象的信息其实就可以实现一些常用的功能了，比如限制文件上传的大小，初步的限制文件上传的类型(当然也可以通过input元素的accept属性来实现，但是最终的类型验证还是需要在服务器端实现)。 File对象一般通过以下途径返回的FileList对象获取： &lt;input type=&quot;file&quot;&gt;的元素 拖拽操作的DataTransfer对象 通过在一个HTMLCanvasElement上调用mozGetAsFile() API 通过input来选择文件1234567/* 假设input元素为&lt;input type=&quot;file&quot; id=&quot;upload&quot; multiple&gt; *///multiple表示一次支持多个文件上传let uploadInput = document.getElementById(&apos;upload&apos;);uploadInput.addEventListener(&apos;change&apos;, ()=&gt;&#123; let fileList = uploadInput.files; console.log(fileList);&#125;); 由于FileList对象并没有forEach()方法，所以一般需要通过for循环来遍历其中的每个File对象：123for (var i = 0; fileCount = fileList.length; i &lt; fileCount; i++) &#123; console.log(fileList[i]);&#125; 但是我们也可以通过其他方式来使用forEach()方法：123456789//1.call方法[].forEach.call(fileList, (file, i, fileList)=&gt;&#123; ...&#125;);//2.ES6方法Array.from(uploadInput).forEach((i)=&gt;&#123; ...&#125;); 通过拖拽(drag&amp;drop)选择文件拖拽事件： drag(开始拖动，持续事件) dragend(释放鼠标或者按下ESC，结束拖动) dragenter(进入有效的拖拽区域时) dragexit(当一个元素不再是拖动操作的直接选择目标时) dragleave(离开有效的拖拽区域时) dragover(悬停在有效的拖拽区域内时，持续事件) dragstart(开始拖动) drop(目标放置到有效的拖拽区域时) 其中需要注意两点： 如果dragover事件不阻止默认事件，drop事件就不会被触发。 dragexit和dragleave在不同浏览器中的触发存在差异，dragexit在Chrome浏览器中就永远不会被触发。 12345678910111213141516171819202122232425262728//拖拽和显示区域&lt;div id=&quot;drop_zone&quot;&gt;Drop files here&lt;/div&gt;&lt;output id=&quot;list&quot;&gt;&lt;/output&gt;&lt;script&gt; function handleFileSelect(evt) &#123; evt.stopPropagation(); evt.preventDefault(); //注意这里不再是target.files let files = evt.dataTransfer.files; let output = []; [].forEach.call(files, (file)=&gt;&#123; output.push(&apos;&lt;li&gt;&lt;strong&gt;&apos;, file.name, &apos;&lt;/strong&gt; (&apos;, file.type || &apos;n/a&apos;, &apos;) - &apos;, (file.size/1024).toFixed(3), &apos; Kb, last modified date: &apos;, file.lastModifiedDate.toLocaleDateString(), &apos;&lt;/li&gt;&apos;); &#125;); document.getElementById(&apos;list&apos;).innerHTML = &apos;&lt;ul&gt;&apos; + output.join(&apos;&apos;) + &apos;&lt;/ul&gt;&apos;; &#125; function handleDragOver(evt) &#123; evt.stopPropagation(); evt.preventDefault(); evt.dataTransfer.dropEffect = &apos;copy&apos;; &#125; let dropZone = document.getElementById(&apos;drop_zone&apos;); dropZone.addEventListener(&apos;dragover&apos;, handleDragOver, false); dropZone.addEventListener(&apos;drop&apos;, handleFileSelect, false);&lt;/script&gt;]]></content>
      <tags>
        <tag>File APIs</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSocket简介]]></title>
    <url>%2F2018%2F04%2F21%2FWebSocket%2F</url>
    <content type="text"><![CDATA[WebSocket 是一种基于TCP的提供全双工/双向通信的通信协议，因为它原生支持跨域，且安全性较高，而且上手容易，是很好的跨域解决方案，甚至可以很容易的搭建一个聊天室。 使用方法客户端12//WebSocket接收两个参数，一个是URL(必须的)，一个是所使用的子协议（可选），可以是字符串也可以是数组，没有指定则为空字符。http使用ws，https使用wssvar ws = new WebSocket(&apos;ws://hostname:port&apos;) 服务器(NodeJS)123//create WebSocket Servervar WebSocketServer = require(&apos;ws&apos;).Server;var wss = new WebSocketServer(&#123;port: 8181&#125;); WebSocket事件 open 123ws.onopen = function(e) &#123; ...&#125; message 123ws.onmessage = function(e) &#123; ...&#125; error 123ws.onerror = function(e) &#123; ...&#125; close 123ws.onclose = function(e) &#123; ...&#125; WebSocket方法 send()可以传输两种类型的之：string和binary；因为WebSocket是事件驱动的协议，所以必须确保连接已经打开并且已经准备好接收信息了。 12345678910111213var ws = new WebSocket(&apos;ws://localhost:8181&apos;);ws.onopen = function(e) &#123; ws.send(JSON.stringigy(stock_request));&#125;//orfunction processEvent(e) &#123; if(ws.readState === WebSocket.OPEN) &#123; //Socket open, send ws.send(e); &#125; else &#123; //Show an error, queue it for sending later, etc &#125;&#125; close() 123ws.close();//or pass a numeric code and human-readable stringws.close(100, &quot;Goodbye, World!&quot;); WebSocket close()方法状态码https://developer.mozilla.org/zh-CN/docs/Web/API/CloseEvent WebSocket 属性当open事件触发后，WebSocket对象会有几个属性可以被客户端应用读取。 readyState| 属性名| 值| 描述|| :——– | ——–:|:– || WebSocket.CONNECTING| 0 | 连接还未打开|| WebSocket.OPEN| 1 | 连接已打开并准备通信|| WebSocket.CLOSING | 2 | 正在关闭连接 || WebSocket.CLOSED | 3 | 连接已关闭 | bufferedAmount常用于发送二进制数据，确保在连接关闭前所有数据已经发送或者在客户端执行某些限制 protocol服务器端所采用的子协议（在使用WebSocket构造器时指定的protocol参数，如果服务器没有采用则为空） 更多WebSocket详细信息参考MDN的WebSocket API]]></content>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS Grid]]></title>
    <url>%2F2018%2F01%2F07%2FCSS-Grid%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[(译)JavaScript的开销]]></title>
    <url>%2F2017%2F12%2F05%2FThe-cost-of-JavaScript%2F</url>
    <content type="text"><![CDATA[当我们建立严重依赖于JavaScript的网站时，我们不总是很容易看到我们发送的内容所付出的代价。在这篇文章中，如果你希望你的网站在移动设备上能够快速加载和互动，我将介绍为什么一些规则可以帮助你。 tl;dr：较少的代码=较少的解析/编译+较少的传输+较少的解压缩 网络当大多数开发人员考虑JavaScript的成本时，他们会考虑下载和执行成本。通过线路发送更多字节的JavaScript需要的时间越长，用户的连接也就越慢。 这可能是一个问题，即使在发达国家，因为用户有效的网络连接类型可能实际上并不是3G，4G或WiFi。你可能在咖啡店使用Wifi，但连接到的是2G的蜂窝热点。 您可以通过以下方式降低 JavaScript的网络传输成本： 只发送用户需要的代码。代码拆分这时候就有用武之地了。 压缩代码（ES515的 Uglify， ES2015的 babel- minify或uglify -es） 高度压缩（使用Brotli〜q11，Zopfli或gzip的）。Brotli的压缩比超过Gzip。它让CertSimple节省了17％的JS压缩字节大小，LinkedIn节省了 4％的加载时间。 删除未使用的代码。通过DevTools代码覆盖来确定。对于剥离的代码，可以查看tree shaking，闭包编译器的高级优化和微调库插件如lodash-babel-plugin插件或WebPack的ContextReplacementPlugin如Moment.js库。使用babel-preset-env和browserlist来避免现代浏览器中已经存在的转译功能。高级开发人员可能会发现仔细分析Webpack捆绑包有助于识别修剪不需要的依赖关系。 使用HTTP缓存以尽量减少网络跳转。确定脚本的最佳生命周期（max-age）和提供令牌验证（ETag）以避免传输没有变更的字节。Service Worker缓存可以使您的应用程序网络具有弹性，让您可以快速访问V8的代码缓存等功能。了解有关文件名哈希的长期缓存。 解析/编译一旦JS下载完毕，JavaScript最大的一个成本就是JS引擎解析/编译这段代码的时间。在Chrome DevTools中，解析和编译是“性能”面板中黄色“脚本”时间的一部分。 Bottom-Up/Call Tree允许查看确切的解析/编译时序：Chrome DevTools“性能”面板&gt;自下而上。通过启用V8的运行时调用统计，我们可以看到分析和编译阶段花费的时间 但是，为什么这会有问题呢？花费很长时间解析/编译代码会严重延迟用户与网站互动的时间。发送的JavaScript越多，在网站交互之前解析和编译的时间就越长。 同样多的字节，浏览器处理JavaScript要比同等大小的图像或Web字体开销更大。 - Tom Dale 与JavaScript相比，在处理等效大小的图片时（涉及到大量的图片仍然需要解码！），涉及到大量的开销，但是在一般的移动设备上，JS更有可能对页面的交互性产生负面影响。JavaScript和图像字节的开销有很大的不同。图像通常不会阻塞主线程，也不会阻止接口在解码和栅格化时进行的交互。然而JS由于解析，编译和执行的成本会延迟交互性。 当我们谈论解析和编译变慢的时候，上下文很重要 - 我们在这里谈论的普通手机。指的是大部分用户使用的CPU和GPU速度较慢的手机，无L2 / L3缓存，甚至可能内存很小。 网络功能和设备功能并不总是相匹配。使用光纤连接的用户不一定有最好的CPU来解析和执行发送到他们的设备的JavaScript。反过来也是如此。一个糟糕的网络连接，但却有一个快速的CPU。 - Kristofer Baxter，LinkedIn 在JavaScript启动性能中，我注意到在低端和高端硬件上解析大约1MB已经被解压的（简单）JavaScript的开销。在市场上最快的手机和普通手机之间解析/编译代码的时间有2-5倍的差异。在不同类别的桌面和移动设备上解析一个1MB的JavaScript包（约有250KB 被gzip压缩了）的解析时间。在查看解析的开销时，解压后的数据要考虑到大约有250KB 被gzip压缩的空间会被释放出来当解压缩大约1MB的代码的时候 那么现实世界的网站如何呢，如CNN.com在高端的iPhone 8上，解析/编译CNN的JS需要花费大约4秒，而普通手机（Moto G4）则只需要13秒。这可以显著影响用户与本网站完全交互的速度。苹果的A11仿生芯片和非常普通的Android硬件中的Snapdragon 617的解析时间性能比较。 这突出了普通硬件（如Moto G4）测试的重要性，而不仅仅是口袋里的手机。但是，使用环境很重要：优化您的用户拥有的设备和网络条件。 分析可以深入了解您的真实用户访问您的网站的移动设备类别。这可以提供机会来了解他们正在使用的真正的CPU / GPU的限制。 我们是否真的发送了太多的JavaScript？错误，这很有可能:) 使用HTTP Archive（最高大约50万个站点）来分析移动设备上JavaScript的状态，我们可以看到，50％的站点需要14秒才能获得交互。仅仅只是解析和编译JS，这些网站就花费长达4秒。 在获取和处理JS和其他资源所花费的时间中，因为感觉网页已经可以使用，用户可能会等待一段时间，这也许并不奇怪。但我们一定可以在这里做得更好。 从网页中删除不重要的JavaScript可以减少传输时间，CPU密集型解析和编译以及潜在的内存开销。这也有助于让您的网页更快地交互。 执行时间这不仅仅是解析和编译，而且可能会带来额外的开销。JavaScript执行（一次解析/编译运行代码）是在主线程上发生的操作之一。很长的执行时间也可以推出用户可以与网站互动的时间。 如果脚本执行时间超过50ms，则交互时间会被下载，编译和执行JS所花时间延迟了 - Alex Russell 为了解决这个问题，JavaScript受益于small chunks，以避免锁定主线程。探索是否可以减少执行过程中正在进行的工作量。 减少JavaScript发送开销的模式当你试图保持JavaScript的解析/编译和网络传输时间很慢时，有一些模式可以帮助像基于路由的分块(route-based chunking)或PRPL。 PRPL是一种通过代码分割和缓存来优化交互性的模式： 让我们看看它可以产生的影响。我们使用V8的运行时调用统计来分析流行移动网站和Progressive Web Apps的加载时间。正如我们所看到的，解析时间（以橙色显示）是许多这些站点花费时间的比较大的部分： Wego是一个使用PRPL的网站，它设法保持较低的路由解析时间，能够非常迅速地进行互动。上面的许多其他站点都采用代码分解和性能预算来降低JS的开销。 其他开销JavaScript可以通过其他方式影响页面性能： 内存。由于GC（垃圾收集），页面可能经常会出现卡顿或暂停。当浏览器回收内存时，JS执行被暂停，所以经常进行垃圾收集的浏览器可以比我们想要的更频繁地暂停执行。避免内存泄漏和频繁的gc暂停，以保持页面流畅。 在运行时，长时间运行的JavaScript可以阻止主线程导致无响应的页面。将工作分成更小的部分（使用requestAnimationFrame（）或有计划的使用requestIdleCallback（））可以最大限度地减少响应性问题。 渐进式引导许多网站将内容可视性作为交互性的代价来优化。为了在有大的JavaScript包时获得一个快速的首页，开发者有时会使用服务器端渲染;然后在JavaScript最终获取时将其“升级”以附加事件处理程序。 小心 - 这有它自己的开销。1）这通常会发送一个更大的 HTML响应，这会延迟交互性，2）这会把用户留在一个离奇的山谷中，其中有一半的实际功能是没有办法交互的，直到JavaScript运行完成。 渐进式引导可能是一个更好的方法。发送一个最小功能的页面（由当前路由所需的HTML / JS / CSS组成）。随着更多的资源到达，该应用程序可以延迟加载和解锁更多的功能。Paul Lewis的渐进式引导视觉 根据所看到的加载代码是圣杯。PRPL和渐进引导是可以帮助实现这一点的模式。 结论传输大小对低端网络至关重要。解析时间对于CPU受限的设备很重要。保持这两者的抵开销。 团队发现成功采用严格的性能预算来保持JavaScript传输和解析/编译时间较短。请参阅Alex Russell的“ 您可以承受吗？：真实世界的Web性能预算 ”，以获取关于移动预算的指导。考虑一下我们制作的架构决策可以为应用程序逻辑留下多少JS“空间”。 如果您正在构建针对移动设备的网站，请尽可能在代表性硬件上开发，保持较低的JavaScript分析/编译时间，并采用性能预算来确保您的团队能够关注其JavaScript成本。 注： 本文版权归原作者所有，仅用于学习与交流； 如需转载译文，烦请按下方注明出处信息，谢谢！原文： The Cost Of JavaScript作者： Addy Osmani译者：smallbone原文地址]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>翻译</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了不起的NodeJS：MongoDB代码更正]]></title>
    <url>%2F2017%2F10%2F01%2Fsmashingnode-master-code%2F</url>
    <content type="text"><![CDATA[最近在学习NodeJS，在网上一番搜索资料后，很多人都建议读《了不起的NodeJS》，于是就开始开始啃起来了。在一边读一边敲代码的的过程中发现书中有些示例中的代码存在书写或者框架的更新导致运行出错，花了不少时间学习框架的更新和库的使用方法，才让代码运行正常。下面就是有关MongoDB代码更正： express实例创建书上的写法1var app = express.createServer(); 更新后的写法1var app = express(); 中间件书上的写法1234//源代码app.use(express.bodyParser());app.use(express.cookieParser());app.use(express.session(&#123;secret: &apos;my secret&apos;&#125;)); 由于新版的express中将原来自身的大部分中间件都移除了，所以需要额外安装并引用。123456789//更正后var session = require(&apos;express-session&apos;);var cookieParser = require(&apos;cookie-parser&apos;);var bodyParser = require(&apos;body-parser&apos;);app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: true &#125;));app.use(cookieParser());app.use(session(&#123;secret: &apos;my secret&apos;&#125;)); bodyParser.urlencoded中的extented设置选项是用来控制POST传递的值是放能被对象化，例如下面的jade模板中input信息1input(name=&quot;user[first]&quot;, type=&quot;text&quot;) { extended: true }: req.body 为 { user: { name: ‘123123’ } }{ extended: false }: req.body 为 { ‘user[name]’: ‘12313’ } Jade模板Jade模板已经更名为Pug，但是仍然可以使用jade。 doctype的变更： doctype 5 =&gt; doctype html 书中index模板中的block body下的代码应该缩进1234567891011//更正后extends layoutblock content if (authenticated) p Welcome back, #&#123;me.first&#125; a(href=&quot;/logout&quot;) Logout else p Welcome new visitor! ul li: a(href=&quot;/login&quot;) Login li: a(href=&quot;/signup&quot;) Signup mongodb新建collection12//源代码app.users = new mongodb.Collection(client, &apos;users&apos;); 这里 Collection 是 mongodb 的方法得用小写,另外在使用 mongodb 之前记得要先用 mongod 命令开启服务器12//更正后app.users = new mongodb.collection(client, &apos;users&apos;); mongodb insert 后的回调使用123456//源代码app.users.insert(req.body.user, function (err, doc) &#123;if (err) next(err);console.log(doc);res.redirect(&apos;/login/&apos; + doc[0].email);&#125;); doc 变成了一个对象，拥有 result 和 ops 两个属性,我们需要的数据在 ops 里面12345app.users.insert(req.body.user, function (err, doc) &#123;if (err) next(err);console.log(doc);res.redirect(&apos;/login/&apos; + doc.ops[0].email);&#125;); 204页忘记传 next 了…12345678//源代码app.post(&apos;/login&apos;, function (req, res) &#123;app.users.findOne(&#123;email: req.body.email, password: req.body.password&#125;, function (err, doc) &#123;if (err) return next(err);if (!doc) return res.send(&apos;&lt;p&gt;User not found &lt;/p&gt;&apos;);req.session.loggedIn = doc._id.toString();&#125;);&#125;); 12345678//更正后app.post(&apos;/login&apos;, function (req, res, next) &#123;app.users.findOne(&#123;email: req.body.email, password: req.body.password&#125;, function (err, doc) &#123;if (err) return next(err);if (!doc) return res.send(&apos;&lt;p&gt;User not found &lt;/p&gt;&apos;);req.session.loggedIn = doc._id.toString();&#125;);&#125;); mongodb的_id查询使用 mongodb 的 _id 进行查询,原文中的指代方法已经不能使用了。而 node 本身不提供生成 objectid 的方法这里需要依赖第三方工具12345//源代码app.users.findOne(&#123;_id: &#123;$oid: req.session.loggedIn&#125;&#125;, function (err, doc) &#123;if (err) return next(err);next();&#125;); 1234567//更正后var objectid = require(&apos;objectid&apos;);app.users.findOne(&#123;_id: objectid(req.session.loggedIn)&#125;, function (err, doc) &#123;if (err) return next(err);next();&#125;); jade中全局变量 locals 的使用1234567891011121314//源代码app.use(function (req, res, next) &#123;if (req.session.loggedIn) &#123;res.local(&apos;auth&apos;, true);app.users.findOne(&#123;_id: objectid(req.session.loggedIn)&#125;, function (err, doc) &#123;if (err) return next(err);res.local(&apos;me&apos;, doc);next();&#125;);&#125; else &#123;res.local(&apos;auth&apos;, false);next();&#125;&#125;); 这里 express 的定义方法更改了,另外使用 mongodb 查询的时候如果没有查找到并不会报错,而是在回调的 doc 设为 null。 1234567891011121314//更正后app.use(function (req, res, next) &#123;if (req.session.loggedIn) &#123;app.locals.auth = true;app.users.findOne(&#123;_id: objectid(req.session.loggedIn)&#125;, function (err, doc) &#123;if (err) return next(err);if (doc) app.locals.me = doc;next();&#125;);&#125; else &#123;app.locals.auth = false;next();&#125;&#125;);]]></content>
      <tags>
        <tag>Node</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的Sets简介]]></title>
    <url>%2F2017%2F07%2F16%2FSets-in-JavaScript%2F</url>
    <content type="text"><![CDATA[Sets 是ES6(ES2015)中一个新的对象类型，用来创建一系列唯一值的集合.集合中的值可以是简单的原始类型如字符串(strings)或整数(integers)，也可以是更复杂的对象类型如对象字面量或者数组 基本方法下面是基本的set及其方法(add, size, has, forEach, delete, clear)的简单示例： 12345678910111213141516171819202122232425let animals = new Set();animals.add('🐷');animals.add('🐼');animals.add('🐢');animals.add('🐿');console.log(animals.size); // 4animals.add('🐼');console.log(animals.size); // 4console.log(animals.has('🐷')); // trueanimals.delete('🐷');console.log(animals.has('🐷')); // falseanimals.forEach(animal =&gt; &#123; console.log(`Hey $&#123;animal&#125;!`);&#125;);// Hey 🐼!// Hey 🐢!// Hey 🐿!animals.clear();console.log(animals.size); // 0 初始化下面是另一个将数组作为初始值传进set的示例。需要主要的是初始化的数组是如何被解构的，但是随后添加的数组将以数组的形式存在： 123456789101112131415let myAnimals = new Set(['🐷', '🐢', '🐷', '🐷']);myAnimals.add(['🐨', '🐑']);myAnimals.add(&#123; name: 'Rud', type: '🐢' &#125;);console.log(myAnimals.size); // 4myAnimals.forEach(animal =&gt; &#123; console.log(animal);&#125;);// 🐷// 🐢// ["🐨", "🐑"]// Object &#123; name: "Rud", type: "🐢" &#125; 字符串也是一个有效的迭代，所以也可以被传入来初始化一个set： 1234console.log('Only unique characters will be in this set.'.length); // 43let sentence = new Set('Only unique characters will be in this set.');console.log(sentence.size); // 18 For…of遍历除了在一个set上可以使用forEach外，for…of循环也可以被用来遍历sets： 12345678910let moreAnimals = new Set(['🐺', '🐴', '🐕', '🐇']);for (let animal of moreAnimals) &#123; console.log(`Howdy $&#123; animal &#125;`);&#125;// Howdy 🐺// Howdy 🐴// Howdy 🐕// Howdy 🐇 Keys 和 ValuesSets也有keys和values方法，由于keys是values的别名，所以两个方法其实是完成一样的事情。使用两者中的任何一个方法都会返回一个新的可迭代的对象，该对象的值与添加到集合中的顺序相同。 123456789101112131415161718192021222324let partyItems = new Set(['🍕', '🍾', '🎊']);let items = partyItems.values();console.log(items.next());console.log(items.next());console.log(items.next());console.log(items.next().done);// Object &#123;// done: false,// value: "🍕"// &#125;// Object &#123;// done: false,// value: "🍾"// &#125;// Object &#123;// done: false,// value: "🎊"// &#125;// true 注： 本文版权归原作者所有，仅用于学习与交流； 如需转载译文，烦请按下方注明出处信息，谢谢！原文： Introduction to Sets in JavaScript作者： alligatorio译者：smallbone译文地址：https://alligator.io//js/sets-introduction/]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Sets</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex Basis与Width的区别]]></title>
    <url>%2F2017%2F07%2F08%2FWidth-FlexBasis%2F</url>
    <content type="text"><![CDATA[最近在学习Flex Box，其中的Flex Box属性中的Flex Basis是关于项目宽度属性设置的，这让许多初学Flex Box的人困惑它与CSS盒子模型Width属性的区别在哪？Google了一番，找到一篇解释写得很是不错的文章，尝试着翻译分享一下。原文地址：http://gedd.ski/post/the-difference-between-width-and-flex-basis/ Flex Items的应用准则content –&gt; width –&gt; flex-basis (limted by max|min-width)也就是说， 如果没有设置flex-basis属性，那么flex-basis的大小就是项目的width属性的大小 如果没有设置width属性，那么flex-basis的大小就是项目内容(content)的大小 下面通过给一个1000px的flex容器来添加一些flex items来说明一下Flex Items的应用准则：1234container &#123; display: flex; width: 1000px;&#125; 设置宽度(Width)添加四个200x200像素的items到flex容器中1234item &#123; width: 200px; height: 200px;&#125; 因为flex容器有足够多的空间，所以items可以很好的填充在容器内部：上面的示例就是当flex-basis没有被指定，默认值是flex-basis: auto，也就意味着items以宽度width(200px)为准。 设置一个Flex Basis值让我们看看当给这些已经设置固定宽度width的items设置一个flex-basis值会发生什么。1234item &#123; width: 30px; flex-basis: 250px;&#125; 就像你说看到的，当指定一个flex-basis值的时候，盒子的宽度属性被忽略了，所以我们就不需要指定盒子的宽度width属性了123item &#123; flex-basis: 250px;&#125; items完全填充了flex容器：因此items的宽度关键在用最终的flex-basis。最佳的方法是只使用flex-basis而不是width或height属性。特别是Safari 10之前的版本的浏览器有一个flexbox bug，在给items应用flex-shrink属性的时候，浏览器会使用height属性而不是flex-basis。 使用max-width来限制flex-basismin-width和max-width会限制flex-basis值。下面是给flex items设置max-width的结果：1234item &#123; flex-basis: 250px; max-width: 100px;&#125; 可以看到即使我们将flex-basis设置为250px，item的宽度还是被限制在了100px。所以在这个示例中最终的flex-basis是100px：接着试试min-width来看看最终的flex-basis有什么不同：1234item &#123; flex-basis: 100px; min-width: 250px;&#125; 可以看到最终item的宽度是250px而不是100px： Flex-basis到底是什么？现在我们知道了width属性只是一个当flex-basis没有被设置时的回退选项。min-width和max-width则是flex-basis的下限和上限。那么flex-basis到底是什么呢？ 也许你注意到了上面我们所有的示例在将flex items放入flex容器之前都直观地列出了flex items的大小。之所以这么做是因为这就是flex-basis的含义：flex items 在被放进一个flex容器之前的大小。也就是items理想或假设的大小。但是flex-basis不能保证其大小！一旦将items放入flex容器中，flex-basis的值就无法保证了。在上面的示例中，你可以看到flex items完美地填充了容器，那是因为容器的大小正好等于items最终的flex-basis之和。但是如果容器没有足够的空间来容纳或者有多余的空间呢？下面就分别讲解一下这两种情况： 当没有足够空间的时候比方说我们想要放更多的flex-basis：200px的items到我们的容器：在items被放进容器之前，每个item会占据200px，所有的items会占据1600px。但是容器只有1000px。当容器没有足够大的空间来存放所有的items的时候，flex items会按照压缩率(shrink rate)被压缩(shrink)其大小来填充容器,这个压缩率就是flex-shrink来设置的，默认情况下每个item的压缩率都是一样的： 当有额外的空间的时候通常我们会有额外的空间剩余当所有的items都添加进容器后：123item &#123; flex-basis: 100px;&#125; 我们可以控制flex items的增长来填充可用的空间，这也就是flex-grow属性的作用。默认值为0，意味着item不会增长。如果将每个item设置flex-grow： 1，那么所有 的item都会等比例的增长来填充剩余的空间：1234item &#123; flex-basis: 100px; flex-grow: 1;&#125; 增长和压缩是flexbox中很重要的特性，也让flexbox非常适合应用于响应式UI设计。Flexbox Zombies课程涵盖了flex-shrink和flex-grow更多详细的细节。 Width vs flex-basis希望现在你明白了width和flex-basis之间的区别，也知道了如何使用min-width和max-width来限制最终的flex-basis。以上这些设置同样适用于height属性，当你将flex-direction设置为column或者column-reverse的时候。如果你想掌握所有的flexbox属性，墙裂推荐免费的Flexbox Zombies课程，通过玩游戏来学习flexbox！]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>FlexBox</tag>
        <tag>翻译</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
</search>