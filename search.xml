<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[WebSocket简介]]></title>
    <url>%2F2018%2F04%2F21%2FWebSocket%2F</url>
    <content type="text"><![CDATA[WebSocket 是一种基于TCP的提供全双工/双向通信的通信协议，因为它原生支持跨域，且安全性较高，而且上手容易，是很好的跨域解决方案，甚至可以很容易的搭建一个聊天室。 使用方法客户端12//WebSocket接收两个参数，一个是URL(必须的)，一个是所使用的子协议（可选），可以是字符串也可以是数组，没有指定则为空字符。http使用ws，https使用wssvar ws = new WebSocket(&apos;ws://hostname:port&apos;) 服务器(NodeJS)123//create WebSocket Servervar WebSocketServer = require(&apos;ws&apos;).Server;var wss = new WebSocketServer(&#123;port: 8181&#125;); WebSocket事件 open 123ws.onopen = function(e) &#123; ...&#125; message 123ws.onmessage = function(e) &#123; ...&#125; error 123ws.onerror = function(e) &#123; ...&#125; close 123ws.onclose = function(e) &#123; ...&#125; WebSocket方法 send()可以传输两种类型的之：string和binary；因为WebSocket是事件驱动的协议，所以必须确保连接已经打开并且已经准备好接收信息了。 12345678910111213var ws = new WebSocket(&apos;ws://localhost:8181&apos;);ws.onopen = function(e) &#123; ws.send(JSON.stringigy(stock_request));&#125;//orfunction processEvent(e) &#123; if(ws.readState === WebSocket.OPEN) &#123; //Socket open, send ws.send(e); &#125; else &#123; //Show an error, queue it for sending later, etc &#125;&#125; close() 123ws.close();//or pass a numeric code and human-readable stringws.close(100, &quot;Goodbye, World!&quot;); WebSocket close()方法状态码https://developer.mozilla.org/zh-CN/docs/Web/API/CloseEvent WebSocket 属性当open事件触发后，WebSocket对象会有几个属性可以被客户端应用读取。 readyState| 属性名| 值| 描述|| :——– | ——–:|:– || WebSocket.CONNECTING| 0 | 连接还未打开|| WebSocket.OPEN| 1 | 连接已打开并准备通信|| WebSocket.CLOSING | 2 | 正在关闭连接 || WebSocket.CLOSED | 3 | 连接已关闭 | bufferedAmount常用于发送二进制数据，确保在连接关闭前所有数据已经发送或者在客户端执行某些限制 protocol服务器端所采用的子协议（在使用WebSocket构造器时指定的protocol参数，如果服务器没有采用则为空） 更多WebSocket详细信息参考MDN的WebSocket API]]></content>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS Grid]]></title>
    <url>%2F2018%2F01%2F07%2FCSS-Grid%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[(译)JavaScript的开销]]></title>
    <url>%2F2017%2F12%2F05%2FThe-cost-of-JavaScript%2F</url>
    <content type="text"><![CDATA[当我们建立严重依赖于JavaScript的网站时，我们不总是很容易看到我们发送的内容所付出的代价。在这篇文章中，如果你希望你的网站在移动设备上能够快速加载和互动，我将介绍为什么一些规则可以帮助你。 tl;dr：较少的代码=较少的解析/编译+较少的传输+较少的解压缩 网络当大多数开发人员考虑JavaScript的成本时，他们会考虑下载和执行成本。通过线路发送更多字节的JavaScript需要的时间越长，用户的连接也就越慢。 这可能是一个问题，即使在发达国家，因为用户有效的网络连接类型可能实际上并不是3G，4G或WiFi。你可能在咖啡店使用Wifi，但连接到的是2G的蜂窝热点。 您可以通过以下方式降低 JavaScript的网络传输成本： 只发送用户需要的代码。代码拆分这时候就有用武之地了。 压缩代码（ES515的 Uglify， ES2015的 babel- minify或uglify -es） 高度压缩（使用Brotli〜q11，Zopfli或gzip的）。Brotli的压缩比超过Gzip。它让CertSimple节省了17％的JS压缩字节大小，LinkedIn节省了 4％的加载时间。 删除未使用的代码。通过DevTools代码覆盖来确定。对于剥离的代码，可以查看tree shaking，闭包编译器的高级优化和微调库插件如lodash-babel-plugin插件或WebPack的ContextReplacementPlugin如Moment.js库。使用babel-preset-env和browserlist来避免现代浏览器中已经存在的转译功能。高级开发人员可能会发现仔细分析Webpack捆绑包有助于识别修剪不需要的依赖关系。 使用HTTP缓存以尽量减少网络跳转。确定脚本的最佳生命周期（max-age）和提供令牌验证（ETag）以避免传输没有变更的字节。Service Worker缓存可以使您的应用程序网络具有弹性，让您可以快速访问V8的代码缓存等功能。了解有关文件名哈希的长期缓存。 解析/编译一旦JS下载完毕，JavaScript最大的一个成本就是JS引擎解析/编译这段代码的时间。在Chrome DevTools中，解析和编译是“性能”面板中黄色“脚本”时间的一部分。 Bottom-Up/Call Tree允许查看确切的解析/编译时序：Chrome DevTools“性能”面板&gt;自下而上。通过启用V8的运行时调用统计，我们可以看到分析和编译阶段花费的时间 但是，为什么这会有问题呢？花费很长时间解析/编译代码会严重延迟用户与网站互动的时间。发送的JavaScript越多，在网站交互之前解析和编译的时间就越长。 同样多的字节，浏览器处理JavaScript要比同等大小的图像或Web字体开销更大。 - Tom Dale 与JavaScript相比，在处理等效大小的图片时（涉及到大量的图片仍然需要解码！），涉及到大量的开销，但是在一般的移动设备上，JS更有可能对页面的交互性产生负面影响。JavaScript和图像字节的开销有很大的不同。图像通常不会阻塞主线程，也不会阻止接口在解码和栅格化时进行的交互。然而JS由于解析，编译和执行的成本会延迟交互性。 当我们谈论解析和编译变慢的时候，上下文很重要 - 我们在这里谈论的普通手机。指的是大部分用户使用的CPU和GPU速度较慢的手机，无L2 / L3缓存，甚至可能内存很小。 网络功能和设备功能并不总是相匹配。使用光纤连接的用户不一定有最好的CPU来解析和执行发送到他们的设备的JavaScript。反过来也是如此。一个糟糕的网络连接，但却有一个快速的CPU。 - Kristofer Baxter，LinkedIn 在JavaScript启动性能中，我注意到在低端和高端硬件上解析大约1MB已经被解压的（简单）JavaScript的开销。在市场上最快的手机和普通手机之间解析/编译代码的时间有2-5倍的差异。在不同类别的桌面和移动设备上解析一个1MB的JavaScript包（约有250KB 被gzip压缩了）的解析时间。在查看解析的开销时，解压后的数据要考虑到大约有250KB 被gzip压缩的空间会被释放出来当解压缩大约1MB的代码的时候 那么现实世界的网站如何呢，如CNN.com在高端的iPhone 8上，解析/编译CNN的JS需要花费大约4秒，而普通手机（Moto G4）则只需要13秒。这可以显著影响用户与本网站完全交互的速度。苹果的A11仿生芯片和非常普通的Android硬件中的Snapdragon 617的解析时间性能比较。 这突出了普通硬件（如Moto G4）测试的重要性，而不仅仅是口袋里的手机。但是，使用环境很重要：优化您的用户拥有的设备和网络条件。 分析可以深入了解您的真实用户访问您的网站的移动设备类别。这可以提供机会来了解他们正在使用的真正的CPU / GPU的限制。 我们是否真的发送了太多的JavaScript？错误，这很有可能:) 使用HTTP Archive（最高大约50万个站点）来分析移动设备上JavaScript的状态，我们可以看到，50％的站点需要14秒才能获得交互。仅仅只是解析和编译JS，这些网站就花费长达4秒。 在获取和处理JS和其他资源所花费的时间中，因为感觉网页已经可以使用，用户可能会等待一段时间，这也许并不奇怪。但我们一定可以在这里做得更好。 从网页中删除不重要的JavaScript可以减少传输时间，CPU密集型解析和编译以及潜在的内存开销。这也有助于让您的网页更快地交互。 执行时间这不仅仅是解析和编译，而且可能会带来额外的开销。JavaScript执行（一次解析/编译运行代码）是在主线程上发生的操作之一。很长的执行时间也可以推出用户可以与网站互动的时间。 如果脚本执行时间超过50ms，则交互时间会被下载，编译和执行JS所花时间延迟了 - Alex Russell 为了解决这个问题，JavaScript受益于small chunks，以避免锁定主线程。探索是否可以减少执行过程中正在进行的工作量。 减少JavaScript发送开销的模式当你试图保持JavaScript的解析/编译和网络传输时间很慢时，有一些模式可以帮助像基于路由的分块(route-based chunking)或PRPL。 PRPL是一种通过代码分割和缓存来优化交互性的模式： 让我们看看它可以产生的影响。我们使用V8的运行时调用统计来分析流行移动网站和Progressive Web Apps的加载时间。正如我们所看到的，解析时间（以橙色显示）是许多这些站点花费时间的比较大的部分： Wego是一个使用PRPL的网站，它设法保持较低的路由解析时间，能够非常迅速地进行互动。上面的许多其他站点都采用代码分解和性能预算来降低JS的开销。 其他开销JavaScript可以通过其他方式影响页面性能： 内存。由于GC（垃圾收集），页面可能经常会出现卡顿或暂停。当浏览器回收内存时，JS执行被暂停，所以经常进行垃圾收集的浏览器可以比我们想要的更频繁地暂停执行。避免内存泄漏和频繁的gc暂停，以保持页面流畅。 在运行时，长时间运行的JavaScript可以阻止主线程导致无响应的页面。将工作分成更小的部分（使用requestAnimationFrame（）或有计划的使用requestIdleCallback（））可以最大限度地减少响应性问题。 渐进式引导许多网站将内容可视性作为交互性的代价来优化。为了在有大的JavaScript包时获得一个快速的首页，开发者有时会使用服务器端渲染;然后在JavaScript最终获取时将其“升级”以附加事件处理程序。 小心 - 这有它自己的开销。1）这通常会发送一个更大的 HTML响应，这会延迟交互性，2）这会把用户留在一个离奇的山谷中，其中有一半的实际功能是没有办法交互的，直到JavaScript运行完成。 渐进式引导可能是一个更好的方法。发送一个最小功能的页面（由当前路由所需的HTML / JS / CSS组成）。随着更多的资源到达，该应用程序可以延迟加载和解锁更多的功能。Paul Lewis的渐进式引导视觉 根据所看到的加载代码是圣杯。PRPL和渐进引导是可以帮助实现这一点的模式。 结论传输大小对低端网络至关重要。解析时间对于CPU受限的设备很重要。保持这两者的抵开销。 团队发现成功采用严格的性能预算来保持JavaScript传输和解析/编译时间较短。请参阅Alex Russell的“ 您可以承受吗？：真实世界的Web性能预算 ”，以获取关于移动预算的指导。考虑一下我们制作的架构决策可以为应用程序逻辑留下多少JS“空间”。 如果您正在构建针对移动设备的网站，请尽可能在代表性硬件上开发，保持较低的JavaScript分析/编译时间，并采用性能预算来确保您的团队能够关注其JavaScript成本。 注： 本文版权归原作者所有，仅用于学习与交流； 如需转载译文，烦请按下方注明出处信息，谢谢！原文： The Cost Of JavaScript作者： Addy Osmani译者：smallbone原文地址]]></content>
      <tags>
        <tag>翻译</tag>
        <tag>JavaScript</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了不起的NodeJS：MongoDB代码更正]]></title>
    <url>%2F2017%2F10%2F01%2Fsmashingnode-master-code%2F</url>
    <content type="text"><![CDATA[最近在学习NodeJS，在网上一番搜索资料后，很多人都建议读《了不起的NodeJS》，于是就开始开始啃起来了。在一边读一边敲代码的的过程中发现书中有些示例中的代码存在书写或者框架的更新导致运行出错，花了不少时间学习框架的更新和库的使用方法，才让代码运行正常。下面就是有关MongoDB代码更正： express实例创建书上的写法1var app = express.createServer(); 更新后的写法1var app = express(); 中间件书上的写法1234//源代码app.use(express.bodyParser());app.use(express.cookieParser());app.use(express.session(&#123;secret: &apos;my secret&apos;&#125;)); 由于新版的express中将原来自身的大部分中间件都移除了，所以需要额外安装并引用。123456789//更正后var session = require(&apos;express-session&apos;);var cookieParser = require(&apos;cookie-parser&apos;);var bodyParser = require(&apos;body-parser&apos;);app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: true &#125;));app.use(cookieParser());app.use(session(&#123;secret: &apos;my secret&apos;&#125;)); bodyParser.urlencoded中的extented设置选项是用来控制POST传递的值是放能被对象化，例如下面的jade模板中input信息1input(name=&quot;user[first]&quot;, type=&quot;text&quot;) { extended: true }: req.body 为 { user: { name: ‘123123’ } }{ extended: false }: req.body 为 { ‘user[name]’: ‘12313’ } Jade模板Jade模板已经更名为Pug，但是仍然可以使用jade。 doctype的变更： doctype 5 =&gt; doctype html 书中index模板中的block body下的代码应该缩进1234567891011//更正后extends layoutblock content if (authenticated) p Welcome back, #&#123;me.first&#125; a(href=&quot;/logout&quot;) Logout else p Welcome new visitor! ul li: a(href=&quot;/login&quot;) Login li: a(href=&quot;/signup&quot;) Signup mongodb新建collection12//源代码app.users = new mongodb.Collection(client, &apos;users&apos;); 这里 Collection 是 mongodb 的方法得用小写,另外在使用 mongodb 之前记得要先用 mongod 命令开启服务器12//更正后app.users = new mongodb.collection(client, &apos;users&apos;); mongodb insert 后的回调使用123456//源代码app.users.insert(req.body.user, function (err, doc) &#123;if (err) next(err);console.log(doc);res.redirect(&apos;/login/&apos; + doc[0].email);&#125;); doc 变成了一个对象，拥有 result 和 ops 两个属性,我们需要的数据在 ops 里面12345app.users.insert(req.body.user, function (err, doc) &#123;if (err) next(err);console.log(doc);res.redirect(&apos;/login/&apos; + doc.ops[0].email);&#125;); 204页忘记传 next 了…12345678//源代码app.post(&apos;/login&apos;, function (req, res) &#123;app.users.findOne(&#123;email: req.body.email, password: req.body.password&#125;, function (err, doc) &#123;if (err) return next(err);if (!doc) return res.send(&apos;&lt;p&gt;User not found &lt;/p&gt;&apos;);req.session.loggedIn = doc._id.toString();&#125;);&#125;); 12345678//更正后app.post(&apos;/login&apos;, function (req, res, next) &#123;app.users.findOne(&#123;email: req.body.email, password: req.body.password&#125;, function (err, doc) &#123;if (err) return next(err);if (!doc) return res.send(&apos;&lt;p&gt;User not found &lt;/p&gt;&apos;);req.session.loggedIn = doc._id.toString();&#125;);&#125;); mongodb的_id查询使用 mongodb 的 _id 进行查询,原文中的指代方法已经不能使用了。而 node 本身不提供生成 objectid 的方法这里需要依赖第三方工具12345//源代码app.users.findOne(&#123;_id: &#123;$oid: req.session.loggedIn&#125;&#125;, function (err, doc) &#123;if (err) return next(err);next();&#125;); 1234567//更正后var objectid = require(&apos;objectid&apos;);app.users.findOne(&#123;_id: objectid(req.session.loggedIn)&#125;, function (err, doc) &#123;if (err) return next(err);next();&#125;); jade中全局变量 locals 的使用1234567891011121314//源代码app.use(function (req, res, next) &#123;if (req.session.loggedIn) &#123;res.local(&apos;auth&apos;, true);app.users.findOne(&#123;_id: objectid(req.session.loggedIn)&#125;, function (err, doc) &#123;if (err) return next(err);res.local(&apos;me&apos;, doc);next();&#125;);&#125; else &#123;res.local(&apos;auth&apos;, false);next();&#125;&#125;); 这里 express 的定义方法更改了,另外使用 mongodb 查询的时候如果没有查找到并不会报错,而是在回调的 doc 设为 null。 1234567891011121314//更正后app.use(function (req, res, next) &#123;if (req.session.loggedIn) &#123;app.locals.auth = true;app.users.findOne(&#123;_id: objectid(req.session.loggedIn)&#125;, function (err, doc) &#123;if (err) return next(err);if (doc) app.locals.me = doc;next();&#125;);&#125; else &#123;app.locals.auth = false;next();&#125;&#125;);]]></content>
      <tags>
        <tag>Node</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的Sets简介]]></title>
    <url>%2F2017%2F07%2F16%2FSets-in-JavaScript%2F</url>
    <content type="text"><![CDATA[Sets 是ES6(ES2015)中一个新的对象类型，用来创建一系列唯一值的集合.集合中的值可以是简单的原始类型如字符串(strings)或整数(integers)，也可以是更复杂的对象类型如对象字面量或者数组 基本方法下面是基本的set及其方法(add, size, has, forEach, delete, clear)的简单示例： 12345678910111213141516171819202122232425let animals = new Set();animals.add('🐷');animals.add('🐼');animals.add('🐢');animals.add('🐿');console.log(animals.size); // 4animals.add('🐼');console.log(animals.size); // 4console.log(animals.has('🐷')); // trueanimals.delete('🐷');console.log(animals.has('🐷')); // falseanimals.forEach(animal =&gt; &#123; console.log(`Hey $&#123;animal&#125;!`);&#125;);// Hey 🐼!// Hey 🐢!// Hey 🐿!animals.clear();console.log(animals.size); // 0 初始化下面是另一个将数组作为初始值传进set的示例。需要主要的是初始化的数组是如何被解构的，但是随后添加的数组将以数组的形式存在： 123456789101112131415let myAnimals = new Set(['🐷', '🐢', '🐷', '🐷']);myAnimals.add(['🐨', '🐑']);myAnimals.add(&#123; name: 'Rud', type: '🐢' &#125;);console.log(myAnimals.size); // 4myAnimals.forEach(animal =&gt; &#123; console.log(animal);&#125;);// 🐷// 🐢// ["🐨", "🐑"]// Object &#123; name: "Rud", type: "🐢" &#125; 字符串也是一个有效的迭代，所以也可以被传入来初始化一个set： 1234console.log('Only unique characters will be in this set.'.length); // 43let sentence = new Set('Only unique characters will be in this set.');console.log(sentence.size); // 18 For…of遍历除了在一个set上可以使用forEach外，for…of循环也可以被用来遍历sets： 12345678910let moreAnimals = new Set(['🐺', '🐴', '🐕', '🐇']);for (let animal of moreAnimals) &#123; console.log(`Howdy $&#123; animal &#125;`);&#125;// Howdy 🐺// Howdy 🐴// Howdy 🐕// Howdy 🐇 Keys 和 ValuesSets也有keys和values方法，由于keys是values的别名，所以两个方法其实是完成一样的事情。使用两者中的任何一个方法都会返回一个新的可迭代的对象，该对象的值与添加到集合中的顺序相同。 123456789101112131415161718192021222324let partyItems = new Set(['🍕', '🍾', '🎊']);let items = partyItems.values();console.log(items.next());console.log(items.next());console.log(items.next());console.log(items.next().done);// Object &#123;// done: false,// value: "🍕"// &#125;// Object &#123;// done: false,// value: "🍾"// &#125;// Object &#123;// done: false,// value: "🎊"// &#125;// true 注： 本文版权归原作者所有，仅用于学习与交流； 如需转载译文，烦请按下方注明出处信息，谢谢！原文： Introduction to Sets in JavaScript作者： alligatorio译者：smallbone译文地址：https://alligator.io//js/sets-introduction/]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Sets</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex Basis与Width的区别]]></title>
    <url>%2F2017%2F07%2F08%2FWidth-FlexBasis%2F</url>
    <content type="text"><![CDATA[最近在学习Flex Box，其中的Flex Box属性中的Flex Basis是关于项目宽度属性设置的，这让许多初学Flex Box的人困惑它与CSS盒子模型Width属性的区别在哪？Google了一番，找到一篇解释写得很是不错的文章，尝试着翻译分享一下。原文地址：http://gedd.ski/post/the-difference-between-width-and-flex-basis/ Flex Items的应用准则content –&gt; width –&gt; flex-basis (limted by max|min-width)也就是说， 如果没有设置flex-basis属性，那么flex-basis的大小就是项目的width属性的大小 如果没有设置width属性，那么flex-basis的大小就是项目内容(content)的大小 下面通过给一个1000px的flex容器来添加一些flex items来说明一下Flex Items的应用准则：1234container &#123; display: flex; width: 1000px;&#125; 设置宽度(Width)添加四个200x200像素的items到flex容器中1234item &#123; width: 200px; height: 200px;&#125; 因为flex容器有足够多的空间，所以items可以很好的填充在容器内部：上面的示例就是当flex-basis没有被指定，默认值是flex-basis: auto，也就意味着items以宽度width(200px)为准。 设置一个Flex Basis值让我们看看当给这些已经设置固定宽度width的items设置一个flex-basis值会发生什么。1234item &#123; width: 30px; flex-basis: 250px;&#125; 就像你说看到的，当指定一个flex-basis值的时候，盒子的宽度属性被忽略了，所以我们就不需要指定盒子的宽度width属性了123item &#123; flex-basis: 250px;&#125; items完全填充了flex容器：因此items的宽度关键在用最终的flex-basis。最佳的方法是只使用flex-basis而不是width或height属性。特别是Safari 10之前的版本的浏览器有一个flexbox bug，在给items应用flex-shrink属性的时候，浏览器会使用height属性而不是flex-basis。 使用max-width来限制flex-basismin-width和max-width会限制flex-basis值。下面是给flex items设置max-width的结果：1234item &#123; flex-basis: 250px; max-width: 100px;&#125; 可以看到即使我们将flex-basis设置为250px，item的宽度还是被限制在了100px。所以在这个示例中最终的flex-basis是100px：接着试试min-width来看看最终的flex-basis有什么不同：1234item &#123; flex-basis: 100px; min-width: 250px;&#125; 可以看到最终item的宽度是250px而不是100px： Flex-basis到底是什么？现在我们知道了width属性只是一个当flex-basis没有被设置时的回退选项。min-width和max-width则是flex-basis的下限和上限。那么flex-basis到底是什么呢？ 也许你注意到了上面我们所有的示例在将flex items放入flex容器之前都直观地列出了flex items的大小。之所以这么做是因为这就是flex-basis的含义：flex items 在被放进一个flex容器之前的大小。也就是items理想或假设的大小。但是flex-basis不能保证其大小！一旦将items放入flex容器中，flex-basis的值就无法保证了。在上面的示例中，你可以看到flex items完美地填充了容器，那是因为容器的大小正好等于items最终的flex-basis之和。但是如果容器没有足够的空间来容纳或者有多余的空间呢？下面就分别讲解一下这两种情况： 当没有足够空间的时候比方说我们想要放更多的flex-basis：200px的items到我们的容器：在items被放进容器之前，每个item会占据200px，所有的items会占据1600px。但是容器只有1000px。当容器没有足够大的空间来存放所有的items的时候，flex items会按照压缩率(shrink rate)被压缩(shrink)其大小来填充容器,这个压缩率就是flex-shrink来设置的，默认情况下每个item的压缩率都是一样的： 当有额外的空间的时候通常我们会有额外的空间剩余当所有的items都添加进容器后：123item &#123; flex-basis: 100px;&#125; 我们可以控制flex items的增长来填充可用的空间，这也就是flex-grow属性的作用。默认值为0，意味着item不会增长。如果将每个item设置flex-grow： 1，那么所有 的item都会等比例的增长来填充剩余的空间：1234item &#123; flex-basis: 100px; flex-grow: 1;&#125; 增长和压缩是flexbox中很重要的特性，也让flexbox非常适合应用于响应式UI设计。Flexbox Zombies课程涵盖了flex-shrink和flex-grow更多详细的细节。 Width vs flex-basis希望现在你明白了width和flex-basis之间的区别，也知道了如何使用min-width和max-width来限制最终的flex-basis。以上这些设置同样适用于height属性，当你将flex-direction设置为column或者column-reverse的时候。如果你想掌握所有的flexbox属性，墙裂推荐免费的Flexbox Zombies课程，通过玩游戏来学习flexbox！]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>FlexBox</tag>
        <tag>翻译</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
</search>