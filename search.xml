<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript中的Sets简介]]></title>
    <url>%2F2017%2F07%2F16%2FSets-in-JavaScript%2F</url>
    <content type="text"><![CDATA[Sets 是ES6(ES2015)中一个新的对象类型，用来创建一系列唯一值的集合.集合中的值可以是简单的原始类型如字符串(strings)或整数(integers)，也可以是更复杂的对象类型如对象字面量或者数组 基本方法下面是基本的set及其方法(add, size, has, forEach, delete, clear)的简单示例： 12345678910111213141516171819202122232425let animals = new Set();animals.add('🐷');animals.add('🐼');animals.add('🐢');animals.add('🐿');console.log(animals.size); // 4animals.add('🐼');console.log(animals.size); // 4console.log(animals.has('🐷')); // trueanimals.delete('🐷');console.log(animals.has('🐷')); // falseanimals.forEach(animal =&gt; &#123; console.log(`Hey $&#123;animal&#125;!`);&#125;);// Hey 🐼!// Hey 🐢!// Hey 🐿!animals.clear();console.log(animals.size); // 0 初始化下面是另一个将数组作为初始值传进set的示例。需要主要的是初始化的数组是如何被解构的，但是随后添加的数组将以数组的形式存在： 123456789101112131415let myAnimals = new Set(['🐷', '🐢', '🐷', '🐷']);myAnimals.add(['🐨', '🐑']);myAnimals.add(&#123; name: 'Rud', type: '🐢' &#125;);console.log(myAnimals.size); // 4myAnimals.forEach(animal =&gt; &#123; console.log(animal);&#125;);// 🐷// 🐢// ["🐨", "🐑"]// Object &#123; name: "Rud", type: "🐢" &#125; 字符串也是一个有效的迭代，所以也可以被传入来初始化一个set： 1234console.log('Only unique characters will be in this set.'.length); // 43let sentence = new Set('Only unique characters will be in this set.');console.log(sentence.size); // 18 For…of遍历除了在一个set上可以使用forEach外，for…of循环也可以被用来遍历sets： 12345678910let moreAnimals = new Set(['🐺', '🐴', '🐕', '🐇']);for (let animal of moreAnimals) &#123; console.log(`Howdy $&#123; animal &#125;`);&#125;// Howdy 🐺// Howdy 🐴// Howdy 🐕// Howdy 🐇 Keys 和 ValuesSets也有keys和values方法，由于keys是values的别名，所以两个方法其实是完成一样的事情。使用两者中的任何一个方法都会返回一个新的可迭代的对象，该对象的值与添加到集合中的顺序相同。 123456789101112131415161718192021222324let partyItems = new Set(['🍕', '🍾', '🎊']);let items = partyItems.values();console.log(items.next());console.log(items.next());console.log(items.next());console.log(items.next().done);// Object &#123;// done: false,// value: "🍕"// &#125;// Object &#123;// done: false,// value: "🍾"// &#125;// Object &#123;// done: false,// value: "🎊"// &#125;// true 注： 本文版权归原作者所有，仅用于学习与交流； 如需转载译文，烦请按下方注明出处信息，谢谢！原文： Introduction to Sets in JavaScript作者： alligatorio译者：smallbone译文地址：https://alligator.io//js/sets-introduction/]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Sets</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex Basis与Width的区别]]></title>
    <url>%2F2017%2F07%2F08%2FWidth-FlexBasis%2F</url>
    <content type="text"><![CDATA[最近在学习Flex Box，其中的Flex Box属性中的Flex Basis是关于项目宽度属性设置的，这让许多初学Flex Box的人困惑它与CSS盒子模型Width属性的区别在哪？Google了一番，找到一篇解释写得很是不错的文章，尝试着翻译分享一下。原文地址：http://gedd.ski/post/the-difference-between-width-and-flex-basis/ Flex Items的应用准则content –&gt; width –&gt; flex-basis (limted by max|min-width)也就是说， 如果没有设置flex-basis属性，那么flex-basis的大小就是项目的width属性的大小 如果没有设置width属性，那么flex-basis的大小就是项目内容(content)的大小 下面通过给一个1000px的flex容器来添加一些flex items来说明一下Flex Items的应用准则：1234container &#123; display: flex; width: 1000px;&#125; 设置宽度(Width)添加四个200x200像素的items到flex容器中1234item &#123; width: 200px; height: 200px;&#125; 因为flex容器有足够多的空间，所以items可以很好的填充在容器内部：上面的示例就是当flex-basis没有被指定，默认值是flex-basis: auto，也就意味着items以宽度width(200px)为准。 设置一个Flex Basis值让我们看看当给这些已经设置固定宽度width的items设置一个flex-basis值会发生什么。1234item &#123; width: 30px; flex-basis: 250px;&#125; 就像你说看到的，当指定一个flex-basis值的时候，盒子的宽度属性被忽略了，所以我们就不需要指定盒子的宽度width属性了123item &#123; flex-basis: 250px;&#125; items完全填充了flex容器：因此items的宽度关键在用最终的flex-basis。最佳的方法是只使用flex-basis而不是width或height属性。特别是Safari 10之前的版本的浏览器有一个flexbox bug，在给items应用flex-shrink属性的时候，浏览器会使用height属性而不是flex-basis。 使用max-width来限制flex-basismin-width和max-width会限制flex-basis值。下面是给flex items设置max-width的结果：1234item &#123; flex-basis: 250px; max-width: 100px;&#125; 可以看到即使我们将flex-basis设置为250px，item的宽度还是被限制在了100px。所以在这个示例中最终的flex-basis是100px：接着试试min-width来看看最终的flex-basis有什么不同：1234item &#123; flex-basis: 100px; min-width: 250px;&#125; 可以看到最终item的宽度是250px而不是100px： Flex-basis到底是什么？现在我们知道了width属性只是一个当flex-basis没有被设置时的回退选项。min-width和max-width则是flex-basis的下限和上限。那么flex-basis到底是什么呢？ 也许你注意到了上面我们所有的示例在将flex items放入flex容器之前都直观地列出了flex items的大小。之所以这么做是因为这就是flex-basis的含义：flex items 在被放进一个flex容器之前的大小。也就是items理想或假设的大小。但是flex-basis不能保证其大小！一旦将items放入flex容器中，flex-basis的值就无法保证了。在上面的示例中，你可以看到flex items完美地填充了容器，那是因为容器的大小正好等于items最终的flex-basis之和。但是如果容器没有足够的空间来容纳或者有多余的空间呢？下面就分别讲解一下这两种情况： 当没有足够空间的时候比方说我们想要放更多的flex-basis：200px的items到我们的容器：在items被放进容器之前，每个item会占据200px，所有的items会占据1600px。但是容器只有1000px。当容器没有足够大的空间来存放所有的items的时候，flex items会按照压缩率(shrink rate)被压缩(shrink)其大小来填充容器,这个压缩率就是flex-shrink来设置的，默认情况下每个item的压缩率都是一样的： 当有额外的空间的时候通常我们会有额外的空间剩余当所有的items都添加进容器后：123item &#123; flex-basis: 100px;&#125; 我们可以控制flex items的增长来填充可用的空间，这也就是flex-grow属性的作用。默认值为0，意味着item不会增长。如果将每个item设置flex-grow： 1，那么所有 的item都会等比例的增长来填充剩余的空间：1234item &#123; flex-basis: 100px; flex-grow: 1;&#125; 增长和压缩是flexbox中很重要的特性，也让flexbox非常适合应用于响应式UI设计。Flexbox Zombies课程涵盖了flex-shrink和flex-grow更多详细的细节。 Width vs flex-basis希望现在你明白了width和flex-basis之间的区别，也知道了如何使用min-width和max-width来限制最终的flex-basis。以上这些设置同样适用于height属性，当你将flex-direction设置为column或者column-reverse的时候。如果你想掌握所有的flexbox属性，墙裂推荐免费的Flexbox Zombies课程，通过玩游戏来学习flexbox！]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>FlexBox</tag>
        <tag>翻译</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
</search>